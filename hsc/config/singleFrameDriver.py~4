import lsst.pipe.drivers.singleFrameDriver
assert type(config)==lsst.pipe.drivers.singleFrameDriver.SingleFrameDriverConfig, 'config is of type %s.%s instead of lsst.pipe.drivers.singleFrameDriver.SingleFrameDriverConfig' % (type(config).__module__, type(config).__name__)
import eups.stack.ProductStack
import lsst.meas.extensions.psfex.psfexPsfDeterminer
import lsst.meas.extensions.psfex._psfexLib
import matplotlib.externals.six.moves.urllib.request
import dateutil.tz
import dateutil.tz.tz
import matplotlib._tri
import eups.hooks
import lsst.meas.extensions.shapeHSM.hsmLib
import matplotlib.offsetbox
import lsst.afw.display.displayLib
import lsst.meas.extensions.shapeHSM._hsmLib
import dateutil
import matplotlib.afm
import eups.distrib
import lsst.meas.modelfit.samplers
import lsst.obs.subaru.crosstalkYagi
import matplotlib.tri.trifinder
import matplotlib.backends._backend_agg
import lsst.meas.modelfit
import lsst.meas.modelfit._modelfitLib
import matplotlib.style.core
import eups.utils
import matplotlib.cbook
import matplotlib.artist
import matplotlib.fontconfig_pattern
import matplotlib.transforms
import lsst.meas.modelfit.modelfitLib
import matplotlib.stackplot
import lsst.pipe.tasks.coaddBase
import eups.distrib.builder
import matplotlib.text
import matplotlib.lines
import matplotlib.tight_bbox
import matplotlib.axes._base
import matplotlib.docstring
import lsst.shapelet.shapeletLib
import matplotlib.backends.qt_compat
import matplotlib.backends.backend_qt5agg
import configparser
import matplotlib.backends.backend_qt5
import matplotlib.tri.triinterpolate
import distutils.sysconfig
import matplotlib.projections
import eups.distrib.tarball
import lsst.afw.display._displayLib
import matplotlib.externals.six.moves
import matplotlib.collections
import matplotlib.legend_handler
import eups.Eups
import lsst.obs.subaru.crosstalk
import eups.distrib.pacman
import eups.distrib.server
import lsst.meas.modelfit.priors
import matplotlib.tri.tritools
import eups.distrib.Distrib
import matplotlib.legend
import matplotlib.tri.tripcolor
import lsst.shapelet.tractor
import cycler
import PyQt5
import lsst.meas.extensions.shapeHSM
import matplotlib.markers
import matplotlib.tri.trirefine
import matplotlib.backends.backend_agg
import matplotlib.axes._subplots
import eups.cmd
import eups.tags
import eups.stack.ProductFamily
import lsst.meas.modelfit.baseMeasure
import matplotlib.tri
import dateutil.tz._common
import lsst.meas.extensions.shapeHSM.version
import matplotlib._cm
import matplotlib.backends.qt_editor
import matplotlib._image
import lsst.meas.modelfit.fitRegion
import lsst.meas.modelfit.measureCoadd
import lsst.pipe.tasks.coaddInputRecorder
import eups
import matplotlib.mlab
import matplotlib._pylab_helpers
import matplotlib.externals.six.moves.urllib.parse
import matplotlib.cm
import matplotlib.colorbar
import eups.db.ChainFile
import dateutil._common
import eups.distrib.Repositories
import lsst.meas.modelfit.measureCcd
import lsst.meas.extensions.psfex.psfex
import lsst.afw.display.rgb
import matplotlib.ft2font
import matplotlib.externals.six
import matplotlib.axes
import matplotlib.axis
import matplotlib.compat
import pyparsing
import matplotlib.backends.qt_editor.formlayout
import matplotlib.texmanager
import matplotlib.rcsetup
import matplotlib.textpath
import matplotlib.bezier
import eups.db
import matplotlib.compat.subprocess
import matplotlib._cntr
import matplotlib
import matplotlib.tri.tricontour
import dateutil.parser
import matplotlib.quiver
import eups.VersionCompare
import lsst.shapelet._shapeletLib
import matplotlib._png
import matplotlib.backends.qt_editor.formsubplottool
import matplotlib._cm_listed
import lsst.meas.modelfit.psf
import matplotlib.spines
import eups.stack
import eups.VersionParser
import matplotlib.tri.triangulation
import matplotlib.dates
import matplotlib.table
import matplotlib.colors
import dateutil.relativedelta
import matplotlib.contour
import lsst.meas.extensions.psfex
import matplotlib.font_manager
import lsst.meas.modelfit.models
import matplotlib._mathtext_data
import lsst.meas.modelfit.measureMulti
import eups.table
import eups.db.VersionFile
import matplotlib.tri.triplot
import matplotlib.container
import matplotlib.projections.polar
import eups.distrib.eupspkg
import matplotlib.patches
import eups.Product
import matplotlib.axes._axes
import matplotlib.gridspec
import sip
import PyQt5.QtWidgets
import lsst.obs.hsc.vignette
import eups.Uses
import matplotlib.backend_tools
import lsst.meas.extensions.psfex.psfexLib
import lsst.meas.extensions
import matplotlib.path
import matplotlib.figure
import lsst.shapelet
import matplotlib.units
import matplotlib.ticker
import lsst.obs.subaru.isr
import eups.distrib.Repository
import eups.app
import matplotlib._contour
import eups.lock
import lsst.pipe.tasks.setConfigFromEups
import matplotlib._version
import lsst.meas.modelfit.version
import dateutil.rrule
import PyQt5.QtGui
import matplotlib.backends.qt_editor.figureoptions
import matplotlib._path
import matplotlib.projections.geo
import lsst.meas.modelfit.measureImage
import lsst.meas.modelfit.cmodel
import PyQt5.QtCore
import matplotlib.widgets
import lsst.meas.modelfit.optimizer
import matplotlib.scale
import matplotlib.streamplot
import matplotlib.externals
import matplotlib.blocking_input
import matplotlib._qhull
import eups.distrib.DistribFactory
import eups.exceptions
import matplotlib.style
import matplotlib.externals.six.moves.urllib
import matplotlib.dviread
import matplotlib.backends
import lsst.meas.extensions.psfex.psfexStarSelector
import matplotlib.pyplot
import matplotlib.mathtext
import matplotlib.backend_bases
import matplotlib.image
import eups.db.Database
import distutils.errors
import lsst.pipe.tasks.selectImages
# DataId key corresponding to a single sensor
config.ccdKey='ccd'

import eups.stack.ProductStack
import lsst.meas.extensions.psfex.psfexPsfDeterminer
import lsst.meas.extensions.psfex._psfexLib
import matplotlib.externals.six.moves.urllib.request
import dateutil.tz
import dateutil.tz.tz
import matplotlib._tri
import eups.hooks
import lsst.meas.extensions.shapeHSM.hsmLib
import matplotlib.offsetbox
import lsst.afw.display.displayLib
import lsst.meas.extensions.shapeHSM._hsmLib
import dateutil
import matplotlib.afm
import eups.distrib
import lsst.meas.modelfit.samplers
import lsst.obs.subaru.crosstalkYagi
import matplotlib.tri.trifinder
import matplotlib.backends._backend_agg
import lsst.meas.modelfit
import lsst.meas.modelfit._modelfitLib
import matplotlib.style.core
import eups.utils
import matplotlib.cbook
import matplotlib.artist
import matplotlib.fontconfig_pattern
import matplotlib.transforms
import lsst.meas.modelfit.modelfitLib
import matplotlib.stackplot
import lsst.pipe.tasks.coaddBase
import eups.distrib.builder
import matplotlib.text
import matplotlib.lines
import matplotlib.tight_bbox
import matplotlib.axes._base
import matplotlib.docstring
import lsst.shapelet.shapeletLib
import matplotlib.backends.qt_compat
import matplotlib.backends.backend_qt5agg
import configparser
import matplotlib.backends.backend_qt5
import matplotlib.tri.triinterpolate
import distutils.sysconfig
import matplotlib.projections
import eups.distrib.tarball
import lsst.afw.display._displayLib
import matplotlib.externals.six.moves
import matplotlib.collections
import matplotlib.legend_handler
import eups.Eups
import lsst.obs.subaru.crosstalk
import eups.distrib.pacman
import eups.distrib.server
import lsst.meas.modelfit.priors
import matplotlib.tri.tritools
import eups.distrib.Distrib
import matplotlib.legend
import matplotlib.tri.tripcolor
import lsst.shapelet.tractor
import cycler
import PyQt5
import lsst.meas.extensions.shapeHSM
import matplotlib.markers
import matplotlib.tri.trirefine
import matplotlib.backends.backend_agg
import matplotlib.axes._subplots
import eups.cmd
import eups.tags
import eups.stack.ProductFamily
import lsst.meas.modelfit.baseMeasure
import matplotlib.tri
import dateutil.tz._common
import lsst.meas.extensions.shapeHSM.version
import matplotlib._cm
import matplotlib.backends.qt_editor
import matplotlib._image
import lsst.meas.modelfit.fitRegion
import lsst.meas.modelfit.measureCoadd
import lsst.pipe.tasks.coaddInputRecorder
import eups
import matplotlib.mlab
import matplotlib._pylab_helpers
import matplotlib.externals.six.moves.urllib.parse
import matplotlib.cm
import matplotlib.colorbar
import eups.db.ChainFile
import dateutil._common
import eups.distrib.Repositories
import lsst.meas.modelfit.measureCcd
import lsst.meas.extensions.psfex.psfex
import lsst.afw.display.rgb
import matplotlib.ft2font
import matplotlib.externals.six
import matplotlib.axes
import matplotlib.axis
import matplotlib.compat
import pyparsing
import matplotlib.backends.qt_editor.formlayout
import matplotlib.texmanager
import matplotlib.rcsetup
import matplotlib.textpath
import matplotlib.bezier
import eups.db
import matplotlib.compat.subprocess
import matplotlib._cntr
import matplotlib
import matplotlib.tri.tricontour
import dateutil.parser
import matplotlib.quiver
import eups.VersionCompare
import lsst.shapelet._shapeletLib
import matplotlib._png
import matplotlib.backends.qt_editor.formsubplottool
import matplotlib._cm_listed
import lsst.meas.modelfit.psf
import matplotlib.spines
import eups.stack
import eups.VersionParser
import matplotlib.tri.triangulation
import matplotlib.dates
import matplotlib.table
import matplotlib.colors
import dateutil.relativedelta
import matplotlib.contour
import lsst.meas.extensions.psfex
import matplotlib.font_manager
import lsst.meas.modelfit.models
import matplotlib._mathtext_data
import lsst.meas.modelfit.measureMulti
import eups.table
import eups.db.VersionFile
import matplotlib.tri.triplot
import matplotlib.container
import matplotlib.projections.polar
import eups.distrib.eupspkg
import matplotlib.patches
import eups.Product
import matplotlib.axes._axes
import matplotlib.gridspec
import sip
import PyQt5.QtWidgets
import lsst.obs.hsc.vignette
import eups.Uses
import matplotlib.backend_tools
import lsst.meas.extensions.psfex.psfexLib
import lsst.meas.extensions
import matplotlib.path
import matplotlib.figure
import lsst.shapelet
import matplotlib.units
import matplotlib.ticker
import lsst.obs.subaru.isr
import eups.distrib.Repository
import eups.app
import matplotlib._contour
import eups.lock
import lsst.pipe.tasks.setConfigFromEups
import matplotlib._version
import lsst.meas.modelfit.version
import dateutil.rrule
import PyQt5.QtGui
import matplotlib.backends.qt_editor.figureoptions
import matplotlib._path
import matplotlib.projections.geo
import lsst.meas.modelfit.measureImage
import lsst.meas.modelfit.cmodel
import PyQt5.QtCore
import matplotlib.widgets
import lsst.meas.modelfit.optimizer
import matplotlib.scale
import matplotlib.streamplot
import matplotlib.externals
import matplotlib.blocking_input
import matplotlib._qhull
import eups.distrib.DistribFactory
import eups.exceptions
import matplotlib.style
import matplotlib.externals.six.moves.urllib
import matplotlib.dviread
import matplotlib.backends
import lsst.meas.extensions.psfex.psfexStarSelector
import matplotlib.pyplot
import matplotlib.mathtext
import matplotlib.backend_bases
import matplotlib.image
import eups.db.Database
import distutils.errors
import lsst.pipe.tasks.selectImages
# Perform calibration?
config.processCcd.doCalibrate=True

import lsst.shapelet
import lsst.shapelet.shapeletLib
import lsst.meas.modelfit.optimizer
import lsst.pipe.tasks.selectImages
import lsst.meas.modelfit.models
import lsst.meas.modelfit.measureCcd
import lsst.meas.modelfit.measureMulti
import lsst.shapelet._shapeletLib
import lsst.meas.modelfit.baseMeasure
import lsst.meas.modelfit.samplers
import lsst.meas.modelfit.psf
import lsst.meas.modelfit.version
import lsst.meas.modelfit
import lsst.meas.modelfit._modelfitLib
import lsst.meas.modelfit.fitRegion
import lsst.meas.modelfit.measureCoadd
import lsst.pipe.tasks.coaddInputRecorder
import lsst.meas.modelfit.priors
import lsst.meas.modelfit.modelfitLib
import lsst.pipe.tasks.coaddBase
import lsst.meas.modelfit.measureImage
import lsst.meas.modelfit.cmodel
import lsst.shapelet.tractor
# Estimated FWHM of simple Gaussian PSF model, in pixels. Ignored if input exposure has a PSF model.
config.processCcd.charImage.installSimplePsf.fwhm=3.5322300675464238

# Width and height of PSF model, in pixels. Must be odd.
# 	Valid Range = [1,inf)
config.processCcd.charImage.installSimplePsf.width=11

# wing width, as a multiple of core width (dimensionless); ignored if addWing false
config.processCcd.charImage.repair.interp.modelPsf.wingFwhmFactor=2.5

# Minimum kernel size if using sizeFactor (pixels); ignored if size is not None
config.processCcd.charImage.repair.interp.modelPsf.minSize=5

# wing amplitude, as a multiple of core amplitude (dimensionless); ignored if addWing false
config.processCcd.charImage.repair.interp.modelPsf.wingAmplitude=0.1

# Kernel size (width and height) (pixels); if None then sizeFactor is used
config.processCcd.charImage.repair.interp.modelPsf.size=None

# Maximum kernel size if using sizeFactor (pixels); ignored if size is not None
config.processCcd.charImage.repair.interp.modelPsf.maxSize=None

# Add a Gaussian to represent wings?
config.processCcd.charImage.repair.interp.modelPsf.addWing=True

# Kernel size as a factor of fwhm (dimensionless); size = sizeFactor * fwhm; ignored if size is not None
config.processCcd.charImage.repair.interp.modelPsf.sizeFactor=3.0

# Default FWHM of Gaussian model of core of star (pixels)
config.processCcd.charImage.repair.interp.modelPsf.defaultFwhm=3.0

# If fallbackValueType is 'USER' then use this as the fallbackValue; ignored otherwise
config.processCcd.charImage.repair.interp.fallbackUserValue=0.0

# Type of statistic to calculate edge fallbackValue for interpolation
# Allowed values:
# 	MEANCLIP	clipped mean
# 	MEAN	mean
# 	USER	user value set in fallbackUserValue config
# 	MEDIAN	median
# 	None	Field is optional
# 
config.processCcd.charImage.repair.interp.fallbackValueType='MEANCLIP'

# Allow negative values for egde interpolation fallbackValue?  If False, set fallbackValue to max(fallbackValue, 0.0)
config.processCcd.charImage.repair.interp.negativeFallbackAllowed=True

# Smoothly taper to the fallback value at the edge of the image?
config.processCcd.charImage.repair.interp.useFallbackValueAtEdge=True

# CRs must have > this many DN (== electrons/gain) in initial detection
config.processCcd.charImage.repair.cosmicray.min_DN=150.0

# maximum number of contaminated pixels
config.processCcd.charImage.repair.cosmicray.nCrPixelMax=1000000

# used in condition 3 for CR; see CR.cc code
config.processCcd.charImage.repair.cosmicray.cond3_fac=2.5

# Don't interpolate over CR pixels
config.processCcd.charImage.repair.cosmicray.keepCRs=False

# CRs must be > this many sky-sig above sky
config.processCcd.charImage.repair.cosmicray.minSigma=6.0

# used in condition 3 for CR; see CR.cc code
config.processCcd.charImage.repair.cosmicray.cond3_fac2=0.4

# number of times to look for contaminated pixels near known CR pixels
config.processCcd.charImage.repair.cosmicray.niteration=3

# Names of mask planes to ignore while estimating the background
config.processCcd.charImage.repair.cosmicray.background.ignoredPixelMask=['BAD', 'EDGE', 'DETECTED', 'DETECTED_NEGATIVE', 'NO_DATA']

# type of statistic to use for grid points
# Allowed values:
# 	MEANCLIP	clipped mean
# 	MEAN	unclipped mean
# 	MEDIAN	median
# 	None	Field is optional
# 
config.processCcd.charImage.repair.cosmicray.background.statisticsProperty='MEDIAN'

# how to interpolate the background values. This maps to an enum; see afw::math::Background
# Allowed values:
# 	AKIMA_SPLINE	higher-level nonlinear spline that is more robust to outliers
# 	CONSTANT	Use a single constant value
# 	None	Field is optional
# 	LINEAR	Use linear interpolation
# 	NATURAL_SPLINE	cubic spline with zero second derivative at endpoints
# 	NONE	No background estimation is to be attempted
# 
config.processCcd.charImage.repair.cosmicray.background.algorithm='AKIMA_SPLINE'

# how large a region of the sky should be used for each background point
# 	Valid Range = [1,inf)
config.processCcd.charImage.repair.cosmicray.background.binSize=100000

# Approximation order in Y for background Chebyshev (valid only with useApprox=True)
config.processCcd.charImage.repair.cosmicray.background.approxOrderY=-1

# Use inverse variance weighting in calculation (valid only with useApprox=True)
config.processCcd.charImage.repair.cosmicray.background.weighting=True

# Ignore NaNs when estimating the background
config.processCcd.charImage.repair.cosmicray.background.isNanSafe=False

# Approximation order in X for background Chebyshev (valid only with useApprox=True)
config.processCcd.charImage.repair.cosmicray.background.approxOrderX=6

# behaviour if there are too few points in grid for requested interpolation style
# Allowed values:
# 	THROW_EXCEPTION	throw an exception if there are too few points
# 	None	Field is optional
# 	INCREASE_NXNYSAMPLE	Increase the number of samples used to make the interpolation grid.
# 	REDUCE_INTERP_ORDER	use an interpolation style with a lower order.
# 
config.processCcd.charImage.repair.cosmicray.background.undersampleStyle='REDUCE_INTERP_ORDER'

# Use Approximate (Chebyshev) to model background.
config.processCcd.charImage.repair.cosmicray.background.useApprox=False

# Find and mask out cosmic rays?
config.processCcd.charImage.repair.doCosmicRay=True

# Interpolate over defects? (ignored unless you provide a list of defects)
config.processCcd.charImage.repair.doInterpolate=True

# Persist results?
config.processCcd.charImage.doWrite=True

# Replace the existing PSF model with a simplified version that has the same sigma at the start of each PSF determination iteration? Doing so makes PSF determination converge more robustly and quickly.
config.processCcd.charImage.useSimplePsf=True

# the maximum match distance is set to  mean_match_distance + matchDistanceSigma*std_dev_match_distance; ignored if not fitting a WCS
# 	Valid Range = [0,inf)
config.processCcd.charImage.ref_match.matchDistanceSigma=2.0

# Minimum number of matched pairs; see also minFracMatchedPairs
# 	Valid Range = [2,inf)
config.processCcd.charImage.ref_match.matcher.minMatchedPairs=30

# Allowed non-perpendicularity of x and y (degree)
# 	Valid Range = [-inf,45.0)
config.processCcd.charImage.ref_match.matcher.allowedNonperpDeg=3.0

# maximum determinant of linear transformation matrix for a usable solution
config.processCcd.charImage.ref_match.matcher.maxDeterminant=0.02

# Type of source flux; typically one of Ap or Psf
config.processCcd.charImage.ref_match.matcher.sourceFluxType='Ap'

# Minimum allowed signal-to-noise ratio for sources used for matching (in the flux specified by sourceFluxType); <=0 for no limit
config.processCcd.charImage.ref_match.matcher.minSnr=40.0

# number of points to define a shape for matching
config.processCcd.charImage.ref_match.matcher.numPointsForShape=6

# Number of bright stars to use
# 	Valid Range = [2,inf)
config.processCcd.charImage.ref_match.matcher.numBrightStars=50

# Minimum number of matched pairs as a fraction of the smaller of the number of reference stars or the number of good sources; the actual minimum is the smaller of this value or minMatchedPairs
# 	Valid Range = [0,1)
config.processCcd.charImage.ref_match.matcher.minFracMatchedPairs=0.3

# Maximum allowed shift of WCS, due to matching (pixel)
# 	Valid Range = [-inf,4000)
config.processCcd.charImage.ref_match.matcher.maxOffsetPix=300

# Rotation angle allowed between sources and position reference objects (degrees)
# 	Valid Range = [-inf,6.0)
config.processCcd.charImage.ref_match.matcher.maxRotationDeg=1.0

# Maximum separation between reference objects and sources beyond which they will not be considered a match (arcsec)
# 	Valid Range = [0,inf)
config.processCcd.charImage.ref_match.matcher.maxMatchDistArcSec=3.0

# number of iterations of PSF candidate star list
config.processCcd.charImage.measurePsf.psfDeterminer['psfex']._PsfexPsfDeterminerConfig__nIterForPsf=3

# number of stars per psf Cell for spatial fitting
config.processCcd.charImage.measurePsf.psfDeterminer['psfex']._PsfexPsfDeterminerConfig__nStarPerCellSpatialFit=5

# Should each PSF candidate be given the same weight, independent of magnitude?
config.processCcd.charImage.measurePsf.psfDeterminer['psfex']._PsfexPsfDeterminerConfig__constantWeight=True

# Should PSFEX be permitted to recentroid PSF candidates?
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].recentroid=False

# tolerance of spatial fitting
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].tolerance=0.01

# number of eigen components for PSF kernel creation
config.processCcd.charImage.measurePsf.psfDeterminer['psfex']._PsfexPsfDeterminerConfig__nEigenComponents=4

# radius of the kernel to create, relative to the square root of the stellar quadrupole moments
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].kernelSize=41.0

# floor for variance is lam*data
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].lam=0.05

# Maximum radius of the kernel
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].kernelSizeMax=45

# specify spatial order for PSF kernel creation
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].spatialOrder=2

# Minimum radius of the kernel
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].kernelSizeMin=25

# Number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measurePsf.psfDeterminer['psfex']._PsfexPsfDeterminerConfig__borderWidth=0

# size of cell used to determine PSF (pixels, row direction)
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].sizeCellY=256

# Resolution of the internal PSF model relative to the pixel size; e.g. 0.5 is equal to 2x oversampling
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].samplingSize=1.0

# for psf candidate evaluation
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].reducedChi2ForPsfCandidates=2.0

# size of cell used to determine PSF (pixels, column direction)
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].sizeCellX=256

# number of stars per psf cell for PSF kernel creation
config.processCcd.charImage.measurePsf.psfDeterminer['psfex']._PsfexPsfDeterminerConfig__nStarPerCell=3

# Rejection threshold (stdev) for candidates based on spatial fit
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].spatialReject=3.0

# List of mask bits which cause a source to be rejected as bad N.b. INTRP is used specially in PsfCandidateSet; it means "Contaminated by neighbour"
config.processCcd.charImage.measurePsf.psfDeterminer['psfex'].badMaskBits=['INTRP', 'SAT']

# number of stars per psf Cell for spatial fitting
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].nStarPerCellSpatialFit=5

# Threshold (stdev) for rejecting extraneous pixels around candidate; applied if positive
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].pixelThreshold=0.0

# number of eigen components for PSF kernel creation
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].nEigenComponents=4

# Use non-linear fitter for spatial variation of Kernel
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].nonLinearSpatialFit=False

# Mask blends in image?
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].doMaskBlends=True

# specify spatial order for PSF kernel creation
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].spatialOrder=2

# tolerance of spatial fitting
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].tolerance=0.01

# Should each PSF candidate be given the same weight, independent of magnitude?
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].constantWeight=True

# radius of the kernel to create, relative to the square root of the stellar quadrupole moments
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].kernelSize=10.0

# Number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].borderWidth=0

# Maximum radius of the kernel
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].kernelSizeMax=45

# floor for variance is lam*data
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].lam=0.05

# Minimum radius of the kernel
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].kernelSizeMin=25

# size of cell used to determine PSF (pixels, row direction)
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].sizeCellY=256

# number of stars per psf cell for PSF kernel creation
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].nStarPerCell=3

# number of iterations of PSF candidate star list
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].nIterForPsf=3

# for psf candidate evaluation
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].reducedChi2ForPsfCandidates=2.0

# size of cell used to determine PSF (pixels, column direction)
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].sizeCellX=256

# Rejection threshold (stdev) for candidates based on spatial fit
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].spatialReject=3.0

# Reject candidates that are blended?
config.processCcd.charImage.measurePsf.psfDeterminer['pca'].doRejectBlends=False

config.processCcd.charImage.measurePsf.psfDeterminer.name='psfex'
# Multiplier of mean for maximum moments histogram range
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].histMomentMaxMultiplier=5.0

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].borderWidth=0

# specify the maximum psfFlux for good Psf Candidates (ignored if == 0)
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].fluxMax=0.0

# specify the minimum psfFlux for good Psf Candidates
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].fluxLim=12500.0

# candidate PSF's shapes must lie within this many sigma of the average shape
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].clumpNSigma=2.0

# Multiplier of mean for minimum moments histogram range
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].histMomentMinMultiplier=2.0

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolatedCenter', 'base_PixelFlags_flag_saturatedCenter', 'base_PixelFlags_flag_crCenter']

# Number of bins in moment histogram
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].histSize=64

# size of the kernel to create
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].kernelSize=21

# Maximum moment to consider
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].histMomentMax=100.0

# Clipping threshold for moments histogram range
config.processCcd.charImage.measurePsf.starSelector['secondMoment'].histMomentClip=5.0

# specify the minimum psfFlux for good Psf Candidates
config.processCcd.charImage.measurePsf.starSelector['objectSize'].fluxMin=4000.0

# minimum width to include in histogram
config.processCcd.charImage.measurePsf.starSelector['objectSize'].widthMin=0.9

# specify the maximum psfFlux for good Psf Candidates (ignored if == 0)
config.processCcd.charImage.measurePsf.starSelector['objectSize'].fluxMax=0.0

# maximum width to include in histogram
config.processCcd.charImage.measurePsf.starSelector['objectSize'].widthMax=10.0

# Keep objects within this many sigma of cluster 0's median
config.processCcd.charImage.measurePsf.starSelector['objectSize'].nSigmaClip=2.0

# Name of field in Source to use for flux measurement
config.processCcd.charImage.measurePsf.starSelector['objectSize'].sourceFluxField='base_PsfFlux_flux'

# Standard deviation of width allowed to be interpreted as good stars
config.processCcd.charImage.measurePsf.starSelector['objectSize'].widthStdAllowed=0.15

# size of the kernel to create
config.processCcd.charImage.measurePsf.starSelector['objectSize'].kernelSize=21

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measurePsf.starSelector['objectSize'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolatedCenter', 'base_PixelFlags_flag_saturatedCenter', 'base_PixelFlags_flag_crCenter', 'base_PixelFlags_flag_bad', 'base_PixelFlags_flag_interpolated']

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measurePsf.starSelector['objectSize'].borderWidth=0

# Max number of bad pixels 
config.processCcd.charImage.measurePsf.starSelector['psfex'].maxbad=0

# Name of photometric flux key 
config.processCcd.charImage.measurePsf.starSelector['psfex'].fluxName='base_PsfFlux'

# Minimum S/N for candidates
config.processCcd.charImage.measurePsf.starSelector['psfex'].minsn=100.0

# Allowed FWHM variability (1.0 = 100%)
config.processCcd.charImage.measurePsf.starSelector['psfex'].maxFwhmVariability=0.2

# Minimum allowed FWHM 
config.processCcd.charImage.measurePsf.starSelector['psfex'].maxFwhm=10.0

# Name of phot. flux err. key
config.processCcd.charImage.measurePsf.starSelector['psfex'].fluxErrName=''

# size of the kernel to create
config.processCcd.charImage.measurePsf.starSelector['psfex'].kernelSize=21

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measurePsf.starSelector['psfex'].borderWidth=0

# Filter bad pixels? 
config.processCcd.charImage.measurePsf.starSelector['psfex'].maxbadflag=True

# Maximum (A-B)/(A+B) 
config.processCcd.charImage.measurePsf.starSelector['psfex'].maxellip=0.3

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measurePsf.starSelector['psfex'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_saturatedCenter', 'base_PixelFlags_flag_crCenter', 'base_PixelFlags_flag_bad', 'base_PixelFlags_flag_suspectCenter', 'base_PsfFlux_flag']

# Maximum allowed FWHM 
config.processCcd.charImage.measurePsf.starSelector['psfex'].minFwhm=2.0

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measurePsf.starSelector['flagged'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolatedCenter', 'base_PixelFlags_flag_saturatedCenter', 'base_PixelFlags_flag_crCenter', 'base_PixelFlags_flag_bad', 'base_PixelFlags_flag_interpolated']

# size of the kernel to create
config.processCcd.charImage.measurePsf.starSelector['flagged'].kernelSize=21

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measurePsf.starSelector['flagged'].borderWidth=0

# Name of a flag field that is True for stars that should be used.
config.processCcd.charImage.measurePsf.starSelector['flagged'].field='calib_psfUsed'

# size of the kernel to create
config.processCcd.charImage.measurePsf.starSelector['catalog'].kernelSize=21

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measurePsf.starSelector['catalog'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolatedCenter', 'base_PixelFlags_flag_saturatedCenter']

# specify the maximum psfFlux for good Psf Candidates (ignored if == 0)
# 	Valid Range = [0.0,inf)
config.processCcd.charImage.measurePsf.starSelector['catalog'].fluxMax=0.0

# specify the minimum psfFlux for good Psf Candidates
# 	Valid Range = [0.0,inf)
config.processCcd.charImage.measurePsf.starSelector['catalog'].fluxLim=0.0

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measurePsf.starSelector['catalog'].borderWidth=0

config.processCcd.charImage.measurePsf.starSelector.name='objectSize'
# This number will be multiplied by the exposure ID to set the random seed for reserving candidates
config.processCcd.charImage.measurePsf.reserveSeed=1

# Fraction of PSF candidates to reserve from fitting; none if <= 0
config.processCcd.charImage.measurePsf.reserveFraction=0.2

# Run subtasks to measure and apply aperture corrections
config.processCcd.charImage.doApCorr=True

# Names of mask planes to ignore while estimating the background
config.processCcd.charImage.background.ignoredPixelMask=['BAD', 'EDGE', 'DETECTED', 'DETECTED_NEGATIVE', 'NO_DATA']

# type of statistic to use for grid points
# Allowed values:
# 	MEANCLIP	clipped mean
# 	MEAN	unclipped mean
# 	MEDIAN	median
# 	None	Field is optional
# 
config.processCcd.charImage.background.statisticsProperty='MEANCLIP'

# how to interpolate the background values. This maps to an enum; see afw::math::Background
# Allowed values:
# 	AKIMA_SPLINE	higher-level nonlinear spline that is more robust to outliers
# 	CONSTANT	Use a single constant value
# 	None	Field is optional
# 	LINEAR	Use linear interpolation
# 	NATURAL_SPLINE	cubic spline with zero second derivative at endpoints
# 	NONE	No background estimation is to be attempted
# 
config.processCcd.charImage.background.algorithm='NATURAL_SPLINE'

# how large a region of the sky should be used for each background point
# 	Valid Range = [1,inf)
config.processCcd.charImage.background.binSize=128

# Approximation order in Y for background Chebyshev (valid only with useApprox=True)
config.processCcd.charImage.background.approxOrderY=-1

# Use inverse variance weighting in calculation (valid only with useApprox=True)
config.processCcd.charImage.background.weighting=True

# Ignore NaNs when estimating the background
config.processCcd.charImage.background.isNanSafe=False

# Approximation order in X for background Chebyshev (valid only with useApprox=True)
config.processCcd.charImage.background.approxOrderX=6

# behaviour if there are too few points in grid for requested interpolation style
# Allowed values:
# 	THROW_EXCEPTION	throw an exception if there are too few points
# 	None	Field is optional
# 	INCREASE_NXNYSAMPLE	Increase the number of samples used to make the interpolation grid.
# 	REDUCE_INTERP_ORDER	use an interpolation style with a lower order.
# 
config.processCcd.charImage.background.undersampleStyle='REDUCE_INTERP_ORDER'

# Use Approximate (Chebyshev) to model background.
config.processCcd.charImage.background.useApprox=True

# Write icExp and icExpBackground in addition to icSrc? Ignored if doWrite False.
config.processCcd.charImage.doWriteExposure=True

# Strictness of Astropy unit compatibility check, can be 'raise', 'warn' or 'silent'
config.processCcd.charImage.checkUnitsParseStrict='raise'

# Default reference catalog filter to use if filter not specified in exposure; if blank then filter must be specified in exposure
config.processCcd.charImage.refObjLoader.defaultFilter=''

# Mapping of camera filter name: reference catalog filter name; each reference filter must exist
config.processCcd.charImage.refObjLoader.filterMap={'N515': 'g', 'V': 'r', 'N387': 'g', 'I': 'i', 'R': 'r', 'r2': 'r', 'B': 'g', 'N1010': 'z', 'N921': 'z', 'N816': 'i', 'i2': 'i'}

# Padding to add to 4 all edges of the bounding box (pixels)
# 	Valid Range = [0,inf)
config.processCcd.charImage.refObjLoader.pixelMargin=50

# Mask planes with the corresponding limit on the fraction of masked pixels. Sources violating this limit will not be deblended.
config.processCcd.charImage.deblend.maskLimits={'NO_DATA': 0.25}

# Chi-squared per DOF cut for deciding a source is PSF during deblending (shifted PSF model)
config.processCcd.charImage.deblend.psfChisq2=1.5

# Only deblend the brightest maxNumberOfPeaks peaks in the parent (<= 0: unlimited)
config.processCcd.charImage.deblend.maxNumberOfPeaks=0

# Footprints smaller in width or height than this value will be ignored; minimum of 2 due to PSF gradient calculation.
# 	Valid Range = [2,inf)
config.processCcd.charImage.deblend.tinyFootprintSize=2

# When splitting stray flux, clip fractions below this value to zero.
config.processCcd.charImage.deblend.clipStrayFluxFraction=0.001

# Minimum axis ratio for footprints before they are ignored as large; non-positive means no threshold applied
config.processCcd.charImage.deblend.minFootprintAxisRatio=0.0

# Maximum area for footprints before they are ignored as large; non-positive means no threshold applied
config.processCcd.charImage.deblend.maxFootprintArea=10000

# If True, catch exceptions thrown by the deblender, log them, and set a flag on the parent, instead of letting them propagate up
config.processCcd.charImage.deblend.catchFailures=False

# What to do when a peak to be deblended is close to the edge of the image
# Allowed values:
# 	noclip	Ignore the edge when building the symmetric template.
# 	ramp	Ramp down flux at the image edge by the PSF
# 	clip	Clip the template at the edge AND the mirror of the edge.
# 	None	Field is optional
# 
config.processCcd.charImage.deblend.edgeHandling='ramp'

# Chi-squared per DOF cut for deciding a source is a PSF during deblending (shifted PSF model #2)
config.processCcd.charImage.deblend.psfChisq2b=1.5

# Maximum linear dimension for footprints before they are ignored as large; non-positive means no threshold applied
config.processCcd.charImage.deblend.maxFootprintSize=0

# If true, a least-squares fit of the templates will be done to the full image. The templates will be re-weighted based on this fit.
config.processCcd.charImage.deblend.weightTemplates=False

# Guarantee that all peaks produce a child source.
config.processCcd.charImage.deblend.propagateAllPeaks=False

# Try to remove similar templates?
config.processCcd.charImage.deblend.removeDegenerateTemplates=False

# If the dot product between two templates is larger than this value, we consider them to be describing the same object (i.e. they are degenerate).  If one of the objects has been labeled as a PSF it will be removed, otherwise the template with the lowest value will be removed.
config.processCcd.charImage.deblend.maxTempDotProd=0.5

# Mask planes to ignore when performing statistics
config.processCcd.charImage.deblend.maskPlanes=['SAT', 'INTRP', 'NO_DATA']

# When the deblender should attribute stray flux to point sources
# Allowed values:
# 	None	Field is optional
# 	always	Always
# 	necessary	When there is not an extended object in the footprint
# 	never	Never; stray flux will not be attributed to any deblended child if the deblender thinks all peaks look like point sources
# 
config.processCcd.charImage.deblend.strayFluxToPointSources='necessary'

# Assign stray flux (not claimed by any child in the deblender) to deblend children.
config.processCcd.charImage.deblend.assignStrayFlux=True

# Chi-squared per DOF cut for deciding a source is a PSF during deblending (un-shifted PSF model)
config.processCcd.charImage.deblend.psfChisq1=1.5

# Mask name for footprints not deblended, or None
config.processCcd.charImage.deblend.notDeblendedMask='NOT_DEBLENDED'

# How to split flux among peaks
# Allowed values:
# 	r-to-footprint	~ 1/(1+R^2) to the closest pixel in the footprint.  CAUTION: this can be computationally expensive on large footprints!
# 	r-to-peak	~ 1/(1+R^2) to the peak
# 	nearest-footprint	Assign 100% to the nearest footprint (using L-1 norm aka Manhattan distance)
# 	trim	Shrink the parent footprint to pixels that are not assigned to children
# 	None	Field is optional
# 
config.processCcd.charImage.deblend.strayFluxRule='trim'

# Run deblender input exposure
config.processCcd.charImage.doDeblend=False

# correction factor for modelFlux error
config.processCcd.charImage.catalogCalculation.plugins['base_ClassificationExtendedness'].modelErrFactor=0.0

# correction factor for psfFlux error
config.processCcd.charImage.catalogCalculation.plugins['base_ClassificationExtendedness'].psfErrFactor=0.0

# critical ratio of model to psf flux
config.processCcd.charImage.catalogCalculation.plugins['base_ClassificationExtendedness'].fluxRatio=0.985

config.processCcd.charImage.catalogCalculation.plugins.names=['base_ClassificationExtendedness']
# Number of iterations of detect sources, measure sources, estimate PSF. If useSimplePsf='all_iter' then 2 should be plenty; otherwise more may be wanted.
# 	Valid Range = [1,inf)
config.processCcd.charImage.psfIterations=2

import lsst.meas.extensions.shapeHSM._hsmLib
import lsst.meas.extensions.shapeHSM.hsmLib
import lsst.meas.extensions.shapeHSM.version
import lsst.meas.extensions.shapeHSM
# Field name for number of deblend children
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeLinear'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeLinear'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeLinear'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_InputCount'].doMeasure=True

# Whether to also compute the shape of the PSF model
config.processCcd.charImage.measurement.undeblended['base_SdssShape'].doMeasurePsf=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_SdssShape'].doMeasure=True

# Convergence tolerance for FWHM
config.processCcd.charImage.measurement.undeblended['base_SdssShape'].tol2=9.999999747378752e-05

# Maximum centroid shift, limited to 2-10
config.processCcd.charImage.measurement.undeblended['base_SdssShape'].maxShift=0.0

# Maximum number of iterations
config.processCcd.charImage.measurement.undeblended['base_SdssShape'].maxIter=100

# Convergence tolerance for e1,e2
config.processCcd.charImage.measurement.undeblended['base_SdssShape'].tol1=9.999999747378752e-06

# Additional value to add to background
config.processCcd.charImage.measurement.undeblended['base_SdssShape'].background=0.0

# Nominal pixel size (arcsec)
config.processCcd.charImage.measurement.undeblended['base_Jacobian'].pixelScale=0.5

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_Jacobian'].doMeasure=True

# Maximum radius (in pixels) for which the sinc algorithm should be used instead of the faster naive algorithm.  For elliptical apertures, this is the minor axis radius.
config.processCcd.charImage.measurement.undeblended['base_CircularApertureFlux'].maxSincRadius=10.0

# Warping kernel used to shift Sinc photometry coefficients to different center positions
config.processCcd.charImage.measurement.undeblended['base_CircularApertureFlux'].shiftKernel='lanczos5'

# Radius (in pixels) of apertures.
config.processCcd.charImage.measurement.undeblended['base_CircularApertureFlux'].radii=[3.0, 4.5, 6.0, 9.0, 12.0, 17.0, 25.0, 35.0, 50.0, 70.0]

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_CircularApertureFlux'].doMeasure=True

# Shapelet order of outer expansion (0 == Gaussian)
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].outerOrder=1

# Shapelet order of inner expansion (0 == Gaussian)
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].innerOrder=2

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].doMeasure=True

# Initial outer radius divided by inner radius
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].radiusRatio=2.0

# Don't allow the semi-major radius of any component to go above this fraction of the PSF image width
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].maxRadiusBoxFraction=0.4

# Don't allow the semi-minor radius of any component to drop below this value (pixels)
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].minRadius=1.0

# Don't allow the determinant radii of the two components to differ by less than this (pixels)
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].minRadiusDiff=0.5

# Initial outer Gaussian peak height divided by inner Gaussian peak height
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].peakRatio=0.1

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowReductionRatio=0.75

# Grow the initial fit ellipses by this factor before comparing with the Kron/Footprint region
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].region.nPsfSigmaGrow=2.0

# Mask planes that indicate pixels that should be ignored in the fit.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].region.badMaskPlanes=['EDGE', 'SAT', 'BAD', 'NO_DATA']

# Use this multiple of the initial fit ellipse then grow by the PSF width to determine the maximum final fit region size.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].region.nFitRadiiMax=3.0

# Maximum fraction of pixels that may be ignored due to masks; more than this and we don't even try.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].region.maxBadPixelFraction=0.1

# Use this multiple of the Kron ellipse to set the fit region (for the final fit region, subject to the nFitRadiiMin and nFitRadiiMax constraints).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].region.nKronRadii=1.5

# Use this multiple of the initial fit ellipse then grow by the PSF width to determine the minimum final fit region size.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].region.nFitRadiiMin=1.0

# If the Kron radius is less than this multiple of the PSF width, ignore it and fall back to a PSF-oriented ellipse scaled to match the area of the footprint or this radius (whichever is larger).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].region.nPsfSigmaMin=4.0

# Abort if the fit region grows beyond this many pixels.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].region.maxArea=100000

# Field name prefix of the Shapelet PSF approximation used to convolve the galaxy model; must contain a set of fields matching the schema defined by shapelet.MultiShapeletFunctionKey.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].psfName='modelfit_DoubleShapeletPsfApprox'

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].doMeasure=True

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.priorName=''

# Whether to record the time spent in this stage
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.profileName='lux'

# Number of Gaussian used to approximate the profile
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.nComponents=3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.gradientThreshold=0.01

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.minTrustRadiusThreshold=0.01

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.usePixelWeights=True

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.ellipticityMaxInner=2.0

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.priorName=''

# Whether to record the time spent in this stage
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.profileName='lux'

# Number of Gaussian used to approximate the profile
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.nComponents=6

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.maxOuterIterations=250

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.usePixelWeights=False

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.ellipticityMaxInner=2.0

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.priorName=''

# Whether to record the time spent in this stage
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.profileName='luv'

# Number of Gaussian used to approximate the profile
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.nComponents=8

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.usePixelWeights=False

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.ellipticityMaxInner=2.0

# Minimum initial radius in pixels (used to regularize initial moments-based PSF deconvolution)
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].minInitialRadius=0.1

# If the 2nd-moments shape used to initialize the fit failed, use the PSF moments multiplied by this.  If <= 0.0, abort the fit early instead.
config.processCcd.charImage.measurement.undeblended['modelfit_CModel'].fallbackInitialMomentsPsfFactor=1.5

# Do check that the centroid is contained in footprint.
config.processCcd.charImage.measurement.undeblended['base_GaussianCentroid'].doFootprintCheck=True

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.charImage.measurement.undeblended['base_GaussianCentroid'].maxDistToPeak=-1.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_GaussianCentroid'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_FPPosition'].doMeasure=True

# Scaling factor of PSF FWHM for aperture radius.
config.processCcd.charImage.measurement.undeblended['base_ScaledApertureFlux'].scale=3.14

# Warping kernel used to shift Sinc photometry coefficients to different center positions
config.processCcd.charImage.measurement.undeblended['base_ScaledApertureFlux'].shiftKernel='lanczos5'

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_ScaledApertureFlux'].doMeasure=True

# Mask planes used to reject bad pixels.
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmSourceMoments'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmSourceMoments'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmPsfMoments'].doMeasure=True

# List of mask planes to be searched for which occur anywhere within a footprint. If any of the planes are found they will have a corresponding pixel flag set.
config.processCcd.charImage.measurement.undeblended['base_PixelFlags'].masksFpAnywhere=[]

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_PixelFlags'].doMeasure=True

# List of mask planes to be searched for which occur in the center of a footprint. If any of the planes are found they will have a corresponding pixel flag set.
config.processCcd.charImage.measurement.undeblended['base_PixelFlags'].masksFpCenter=[]

# FIXME! NEVER DOCUMENTED!
config.processCcd.charImage.measurement.undeblended['base_GaussianFlux'].background=0.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_GaussianFlux'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_SkyCoord'].doMeasure=True

# Scale factor to apply to shape for aperture
config.processCcd.charImage.measurement.undeblended['base_Variance'].scale=5.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_Variance'].doMeasure=True

# Mask planes to ignore
config.processCcd.charImage.measurement.undeblended['base_Variance'].mask=['DETECTED', 'DETECTED_NEGATIVE', 'BAD', 'SAT']

# Whether to compute quantities related to the Gaussian-weighted shape
config.processCcd.charImage.measurement.undeblended['base_Blendedness'].doShape=True

# Whether to compute quantities related to the Gaussian-weighted flux
config.processCcd.charImage.measurement.undeblended['base_Blendedness'].doFlux=True

# Whether to compute HeavyFootprint dot products (the old deblend.blendedness parameter)
config.processCcd.charImage.measurement.undeblended['base_Blendedness'].doOld=True

# Radius factor that sets the maximum extent of the weight function (and hence the flux measurements)
config.processCcd.charImage.measurement.undeblended['base_Blendedness'].nSigmaWeightMax=3.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_Blendedness'].doMeasure=True

# Field name for number of deblend children
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeRegauss'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeRegauss'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeRegauss'].doMeasure=True

# Name of warping kernel (e.g. "lanczos4") used to compute the peak
config.processCcd.charImage.measurement.undeblended['base_PeakLikelihoodFlux'].warpingKernelName='lanczos4'

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_PeakLikelihoodFlux'].doMeasure=True

# a sequence of model names indicating which models should be fit, and their order
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].sequence=['DoubleShapelet']

config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models={}
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.order=2

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.order=1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.order=4

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.order=4

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowReductionRatio=0.75

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].doMeasure=True

# Field name for number of deblend children
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeKsb'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeKsb'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeKsb'].doMeasure=True

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.undeblended['base_PsfFlux'].badMaskPlanes=[]

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_PsfFlux'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_PeakCentroid'].doMeasure=True

# Do check that the centroid is contained in footprint.
config.processCcd.charImage.measurement.undeblended['base_NaiveCentroid'].doFootprintCheck=True

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.charImage.measurement.undeblended['base_NaiveCentroid'].maxDistToPeak=-1.0

# Value to subtract from the image pixel values
config.processCcd.charImage.measurement.undeblended['base_NaiveCentroid'].background=0.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_NaiveCentroid'].doMeasure=True

# Field name for number of deblend children
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeBj'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeBj'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['ext_shapeHSM_HsmShapeBj'].doMeasure=True

# Do check that the centroid is contained in footprint.
config.processCcd.charImage.measurement.undeblended['base_SdssCentroid'].doFootprintCheck=True

# if the peak's less than this insist on binning at least once
config.processCcd.charImage.measurement.undeblended['base_SdssCentroid'].peakMin=-1.0

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.charImage.measurement.undeblended['base_SdssCentroid'].maxDistToPeak=-1.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.undeblended['base_SdssCentroid'].doMeasure=True

# fiddle factor for adjusting the binning
config.processCcd.charImage.measurement.undeblended['base_SdssCentroid'].wfac=1.5

# maximum allowed binning
config.processCcd.charImage.measurement.undeblended['base_SdssCentroid'].binmax=16

config.processCcd.charImage.measurement.undeblended.names=[]
# The seed multiplier value to use for random number generation
#    >= 1: set the seed deterministically based on exposureId
#       0: fall back to the afw.math.Random default constructor (which uses a seed value of 1)
config.processCcd.charImage.measurement.noiseReplacer.noiseSeedMultiplier=1

# Add ann offset to the generated noise.
config.processCcd.charImage.measurement.noiseReplacer.noiseOffset=0.0

# How to choose mean and variance of the Gaussian noise we generate?
# Allowed values:
# 	measure	Measure clipped mean and variance from the whole image
# 	variance	Mean = 0, variance = the image's variance
# 	meta	Mean = 0, variance = the "BGMEAN" metadata entry
# 
config.processCcd.charImage.measurement.noiseReplacer.noiseSource='measure'

# the name of the algorithm used to set the source model flux slot
config.processCcd.charImage.measurement.slots.modelFlux='modelfit_CModel'

# the name of the flux measurement algorithm used for calibration
config.processCcd.charImage.measurement.slots.calibFlux='base_CircularApertureFlux_12_0'

# the name of the algorithm used to set the source psf flux slot
config.processCcd.charImage.measurement.slots.psfFlux='base_PsfFlux'

# the name of the centroiding algorithm used to set source x,y
config.processCcd.charImage.measurement.slots.centroid='base_SdssCentroid'

# the name of the algorithm used to set the source aperture flux slot
config.processCcd.charImage.measurement.slots.apFlux='base_CircularApertureFlux_12_0'

# the name of the algorithm used to set the source inst flux slot
config.processCcd.charImage.measurement.slots.instFlux='base_GaussianFlux'

# the name of the algorithm used to set source moments parameters
config.processCcd.charImage.measurement.slots.shape='ext_shapeHSM_HsmSourceMoments'

# Field name for number of deblend children
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeLinear'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeLinear'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeLinear'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_InputCount'].doMeasure=True

# Whether to also compute the shape of the PSF model
config.processCcd.charImage.measurement.plugins['base_SdssShape'].doMeasurePsf=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_SdssShape'].doMeasure=True

# Convergence tolerance for FWHM
config.processCcd.charImage.measurement.plugins['base_SdssShape'].tol2=9.999999747378752e-05

# Maximum centroid shift, limited to 2-10
config.processCcd.charImage.measurement.plugins['base_SdssShape'].maxShift=0.0

# Maximum number of iterations
config.processCcd.charImage.measurement.plugins['base_SdssShape'].maxIter=100

# Convergence tolerance for e1,e2
config.processCcd.charImage.measurement.plugins['base_SdssShape'].tol1=9.999999747378752e-06

# Additional value to add to background
config.processCcd.charImage.measurement.plugins['base_SdssShape'].background=0.0

# Nominal pixel size (arcsec)
config.processCcd.charImage.measurement.plugins['base_Jacobian'].pixelScale=0.168

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_Jacobian'].doMeasure=True

# Maximum radius (in pixels) for which the sinc algorithm should be used instead of the faster naive algorithm.  For elliptical apertures, this is the minor axis radius.
config.processCcd.charImage.measurement.plugins['base_CircularApertureFlux'].maxSincRadius=12.0

# Warping kernel used to shift Sinc photometry coefficients to different center positions
config.processCcd.charImage.measurement.plugins['base_CircularApertureFlux'].shiftKernel='lanczos5'

# Radius (in pixels) of apertures.
config.processCcd.charImage.measurement.plugins['base_CircularApertureFlux'].radii=[3.0, 4.5, 6.0, 9.0, 12.0, 17.0, 25.0, 35.0, 50.0, 70.0]

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_CircularApertureFlux'].doMeasure=True

# Shapelet order of outer expansion (0 == Gaussian)
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].outerOrder=1

# Shapelet order of inner expansion (0 == Gaussian)
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].innerOrder=2

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].doMeasure=True

# Initial outer radius divided by inner radius
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].radiusRatio=2.0

# Don't allow the semi-major radius of any component to go above this fraction of the PSF image width
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].maxRadiusBoxFraction=0.4

# Don't allow the semi-minor radius of any component to drop below this value (pixels)
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].minRadius=1.0

# Don't allow the determinant radii of the two components to differ by less than this (pixels)
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].minRadiusDiff=0.5

# Initial outer Gaussian peak height divided by inner Gaussian peak height
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].peakRatio=0.1

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowReductionRatio=0.75

# Grow the initial fit ellipses by this factor before comparing with the Kron/Footprint region
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].region.nPsfSigmaGrow=2.0

# Mask planes that indicate pixels that should be ignored in the fit.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].region.badMaskPlanes=['EDGE', 'SAT', 'BAD', 'NO_DATA']

# Use this multiple of the initial fit ellipse then grow by the PSF width to determine the maximum final fit region size.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].region.nFitRadiiMax=3.0

# Maximum fraction of pixels that may be ignored due to masks; more than this and we don't even try.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].region.maxBadPixelFraction=0.1

# Use this multiple of the Kron ellipse to set the fit region (for the final fit region, subject to the nFitRadiiMin and nFitRadiiMax constraints).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].region.nKronRadii=1.5

# Use this multiple of the initial fit ellipse then grow by the PSF width to determine the minimum final fit region size.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].region.nFitRadiiMin=1.0

# If the Kron radius is less than this multiple of the PSF width, ignore it and fall back to a PSF-oriented ellipse scaled to match the area of the footprint or this radius (whichever is larger).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].region.nPsfSigmaMin=4.0

# Abort if the fit region grows beyond this many pixels.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].region.maxArea=100000

# Field name prefix of the Shapelet PSF approximation used to convolve the galaxy model; must contain a set of fields matching the schema defined by shapelet.MultiShapeletFunctionKey.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].psfName='modelfit_DoubleShapeletPsfApprox'

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].doMeasure=True

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.priorName=''

# Whether to record the time spent in this stage
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.profileName='lux'

# Number of Gaussian used to approximate the profile
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.nComponents=3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.gradientThreshold=0.01

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.minTrustRadiusThreshold=0.01

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.usePixelWeights=True

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.ellipticityMaxInner=2.0

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.priorName=''

# Whether to record the time spent in this stage
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.profileName='lux'

# Number of Gaussian used to approximate the profile
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.nComponents=6

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.maxOuterIterations=250

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.usePixelWeights=False

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.ellipticityMaxInner=2.0

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.priorName=''

# Whether to record the time spent in this stage
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.profileName='luv'

# Number of Gaussian used to approximate the profile
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.nComponents=8

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.usePixelWeights=False

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.ellipticityMaxInner=2.0

# Minimum initial radius in pixels (used to regularize initial moments-based PSF deconvolution)
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].minInitialRadius=0.1

# If the 2nd-moments shape used to initialize the fit failed, use the PSF moments multiplied by this.  If <= 0.0, abort the fit early instead.
config.processCcd.charImage.measurement.plugins['modelfit_CModel'].fallbackInitialMomentsPsfFactor=1.5

# Do check that the centroid is contained in footprint.
config.processCcd.charImage.measurement.plugins['base_GaussianCentroid'].doFootprintCheck=True

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.charImage.measurement.plugins['base_GaussianCentroid'].maxDistToPeak=-1.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_GaussianCentroid'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_FPPosition'].doMeasure=True

# Scaling factor of PSF FWHM for aperture radius.
config.processCcd.charImage.measurement.plugins['base_ScaledApertureFlux'].scale=3.14

# Warping kernel used to shift Sinc photometry coefficients to different center positions
config.processCcd.charImage.measurement.plugins['base_ScaledApertureFlux'].shiftKernel='lanczos5'

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_ScaledApertureFlux'].doMeasure=True

# Mask planes used to reject bad pixels.
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmSourceMoments'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmSourceMoments'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmPsfMoments'].doMeasure=True

# List of mask planes to be searched for which occur anywhere within a footprint. If any of the planes are found they will have a corresponding pixel flag set.
config.processCcd.charImage.measurement.plugins['base_PixelFlags'].masksFpAnywhere=[]

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_PixelFlags'].doMeasure=True

# List of mask planes to be searched for which occur in the center of a footprint. If any of the planes are found they will have a corresponding pixel flag set.
config.processCcd.charImage.measurement.plugins['base_PixelFlags'].masksFpCenter=[]

# FIXME! NEVER DOCUMENTED!
config.processCcd.charImage.measurement.plugins['base_GaussianFlux'].background=0.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_GaussianFlux'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_SkyCoord'].doMeasure=True

# Scale factor to apply to shape for aperture
config.processCcd.charImage.measurement.plugins['base_Variance'].scale=5.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_Variance'].doMeasure=True

# Mask planes to ignore
config.processCcd.charImage.measurement.plugins['base_Variance'].mask=['DETECTED', 'DETECTED_NEGATIVE', 'BAD', 'SAT']

# Whether to compute quantities related to the Gaussian-weighted shape
config.processCcd.charImage.measurement.plugins['base_Blendedness'].doShape=True

# Whether to compute quantities related to the Gaussian-weighted flux
config.processCcd.charImage.measurement.plugins['base_Blendedness'].doFlux=True

# Whether to compute HeavyFootprint dot products (the old deblend.blendedness parameter)
config.processCcd.charImage.measurement.plugins['base_Blendedness'].doOld=True

# Radius factor that sets the maximum extent of the weight function (and hence the flux measurements)
config.processCcd.charImage.measurement.plugins['base_Blendedness'].nSigmaWeightMax=3.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_Blendedness'].doMeasure=True

# Field name for number of deblend children
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeRegauss'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeRegauss'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeRegauss'].doMeasure=True

# Name of warping kernel (e.g. "lanczos4") used to compute the peak
config.processCcd.charImage.measurement.plugins['base_PeakLikelihoodFlux'].warpingKernelName='lanczos4'

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_PeakLikelihoodFlux'].doMeasure=True

# a sequence of model names indicating which models should be fit, and their order
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].sequence=['DoubleShapelet']

config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models={}
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.order=2

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.order=1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.order=4

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.order=4

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowReductionRatio=0.75

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].doMeasure=True

# Field name for number of deblend children
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeKsb'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeKsb'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeKsb'].doMeasure=True

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.plugins['base_PsfFlux'].badMaskPlanes=[]

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_PsfFlux'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_PeakCentroid'].doMeasure=True

# Do check that the centroid is contained in footprint.
config.processCcd.charImage.measurement.plugins['base_NaiveCentroid'].doFootprintCheck=True

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.charImage.measurement.plugins['base_NaiveCentroid'].maxDistToPeak=-1.0

# Value to subtract from the image pixel values
config.processCcd.charImage.measurement.plugins['base_NaiveCentroid'].background=0.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_NaiveCentroid'].doMeasure=True

# Field name for number of deblend children
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeBj'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeBj'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['ext_shapeHSM_HsmShapeBj'].doMeasure=True

# Do check that the centroid is contained in footprint.
config.processCcd.charImage.measurement.plugins['base_SdssCentroid'].doFootprintCheck=True

# if the peak's less than this insist on binning at least once
config.processCcd.charImage.measurement.plugins['base_SdssCentroid'].peakMin=-1.0

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.charImage.measurement.plugins['base_SdssCentroid'].maxDistToPeak=-1.0

# whether to run this plugin in single-object mode
config.processCcd.charImage.measurement.plugins['base_SdssCentroid'].doMeasure=True

# fiddle factor for adjusting the binning
config.processCcd.charImage.measurement.plugins['base_SdssCentroid'].wfac=1.5

# maximum allowed binning
config.processCcd.charImage.measurement.plugins['base_SdssCentroid'].binmax=16

config.processCcd.charImage.measurement.plugins.names=['ext_shapeHSM_HsmSourceMoments', 'modelfit_CModel', 'base_SdssShape', 'ext_shapeHSM_HsmShapeRegauss', 'base_CircularApertureFlux', 'modelfit_DoubleShapeletPsfApprox', 'base_Jacobian', 'base_FPPosition', 'ext_shapeHSM_HsmPsfMoments', 'base_PsfFlux', 'base_PixelFlags', 'base_GaussianFlux', 'base_SdssCentroid']
# Prefix to give undeblended plugins
config.processCcd.charImage.measurement.undeblendedPrefix='undeblended_'

# When measuring, replace other detected footprints with noise?
config.processCcd.charImage.measurement.doReplaceWithNoise=True

# flux measurement algorithms in getApCorrNameSet() to ignore; if a name is listed that does not appear in getApCorrNameSet() then a warning is logged
config.processCcd.charImage.applyApCorr.ignoreList=[]

# flux measurement algorithms to be aperture-corrected by reference to another algorithm; this is a mapping alg1:alg2, where 'alg1' is the algorithm being corrected, and 'alg2' is the algorithm supplying the corrections
config.processCcd.charImage.applyApCorr.proxies={}

# set the general failure flag for a flux when it cannot be aperture-corrected?
config.processCcd.charImage.applyApCorr.doFlagApCorrFailures=True

# Pixels should be grown as isotropically as possible (slower)
config.processCcd.charImage.detection.isotropicGrow=True

# Threshold for footprints
# 	Valid Range = [0.0,inf)
config.processCcd.charImage.detection.thresholdValue=5.0

# Grow detections to set the image mask bits, but return the original (not-grown) footprints
config.processCcd.charImage.detection.returnOriginalFootprints=False

# specifies the desired flavor of Threshold
# Allowed values:
# 	variance	threshold applied to image variance
# 	stdev	threshold applied to image std deviation
# 	value	threshold applied to image value
# 	pixel_stdev	threshold applied to per-pixel std deviation
# 
config.processCcd.charImage.detection.thresholdType='stdev'

# Include threshold relative to thresholdValue
# 	Valid Range = [0.0,inf)
config.processCcd.charImage.detection.includeThresholdMultiplier=10.0

# Estimate the background again after final source detection?
config.processCcd.charImage.detection.reEstimateBackground=True

# detected sources with fewer than the specified number of pixels will be ignored
# 	Valid Range = [0,inf)
config.processCcd.charImage.detection.minPixels=1

# Names of mask planes to ignore while estimating the background
config.processCcd.charImage.detection.tempLocalBackground.ignoredPixelMask=['BAD', 'EDGE', 'DETECTED', 'DETECTED_NEGATIVE', 'NO_DATA']

# type of statistic to use for grid points
# Allowed values:
# 	MEANCLIP	clipped mean
# 	MEAN	unclipped mean
# 	MEDIAN	median
# 	None	Field is optional
# 
config.processCcd.charImage.detection.tempLocalBackground.statisticsProperty='MEANCLIP'

# how to interpolate the background values. This maps to an enum; see afw::math::Background
# Allowed values:
# 	AKIMA_SPLINE	higher-level nonlinear spline that is more robust to outliers
# 	CONSTANT	Use a single constant value
# 	None	Field is optional
# 	LINEAR	Use linear interpolation
# 	NATURAL_SPLINE	cubic spline with zero second derivative at endpoints
# 	NONE	No background estimation is to be attempted
# 
config.processCcd.charImage.detection.tempLocalBackground.algorithm='AKIMA_SPLINE'

# how large a region of the sky should be used for each background point
# 	Valid Range = [1,inf)
config.processCcd.charImage.detection.tempLocalBackground.binSize=64

# Approximation order in Y for background Chebyshev (valid only with useApprox=True)
config.processCcd.charImage.detection.tempLocalBackground.approxOrderY=-1

# Use inverse variance weighting in calculation (valid only with useApprox=True)
config.processCcd.charImage.detection.tempLocalBackground.weighting=True

# Ignore NaNs when estimating the background
config.processCcd.charImage.detection.tempLocalBackground.isNanSafe=False

# Approximation order in X for background Chebyshev (valid only with useApprox=True)
config.processCcd.charImage.detection.tempLocalBackground.approxOrderX=6

# behaviour if there are too few points in grid for requested interpolation style
# Allowed values:
# 	THROW_EXCEPTION	throw an exception if there are too few points
# 	None	Field is optional
# 	INCREASE_NXNYSAMPLE	Increase the number of samples used to make the interpolation grid.
# 	REDUCE_INTERP_ORDER	use an interpolation style with a lower order.
# 
config.processCcd.charImage.detection.tempLocalBackground.undersampleStyle='REDUCE_INTERP_ORDER'

# Use Approximate (Chebyshev) to model background.
config.processCcd.charImage.detection.tempLocalBackground.useApprox=False

# Grow detections by nSigmaToGrow * sigma; if 0 then do not grow
config.processCcd.charImage.detection.nSigmaToGrow=2.4

# Names of mask planes to ignore while estimating the background
config.processCcd.charImage.detection.background.ignoredPixelMask=['BAD', 'EDGE', 'DETECTED', 'DETECTED_NEGATIVE', 'NO_DATA']

# type of statistic to use for grid points
# Allowed values:
# 	MEANCLIP	clipped mean
# 	MEAN	unclipped mean
# 	MEDIAN	median
# 	None	Field is optional
# 
config.processCcd.charImage.detection.background.statisticsProperty='MEANCLIP'

# how to interpolate the background values. This maps to an enum; see afw::math::Background
# Allowed values:
# 	AKIMA_SPLINE	higher-level nonlinear spline that is more robust to outliers
# 	CONSTANT	Use a single constant value
# 	None	Field is optional
# 	LINEAR	Use linear interpolation
# 	NATURAL_SPLINE	cubic spline with zero second derivative at endpoints
# 	NONE	No background estimation is to be attempted
# 
config.processCcd.charImage.detection.background.algorithm='NATURAL_SPLINE'

# how large a region of the sky should be used for each background point
# 	Valid Range = [1,inf)
config.processCcd.charImage.detection.background.binSize=128

# Approximation order in Y for background Chebyshev (valid only with useApprox=True)
config.processCcd.charImage.detection.background.approxOrderY=-1

# Use inverse variance weighting in calculation (valid only with useApprox=True)
config.processCcd.charImage.detection.background.weighting=True

# Ignore NaNs when estimating the background
config.processCcd.charImage.detection.background.isNanSafe=False

# Approximation order in X for background Chebyshev (valid only with useApprox=True)
config.processCcd.charImage.detection.background.approxOrderX=6

# behaviour if there are too few points in grid for requested interpolation style
# Allowed values:
# 	THROW_EXCEPTION	throw an exception if there are too few points
# 	None	Field is optional
# 	INCREASE_NXNYSAMPLE	Increase the number of samples used to make the interpolation grid.
# 	REDUCE_INTERP_ORDER	use an interpolation style with a lower order.
# 
config.processCcd.charImage.detection.background.undersampleStyle='REDUCE_INTERP_ORDER'

# Use Approximate (Chebyshev) to model background.
config.processCcd.charImage.detection.background.useApprox=True

# Do temporary interpolated background subtraction before footprint detection?
config.processCcd.charImage.detection.doTempLocalBackground=False

# specifies whether to detect positive, or negative sources, or both
# Allowed values:
# 	positive	detect only positive sources
# 	negative	detect only negative sources
# 	both	detect both positive and negative sources
# 
config.processCcd.charImage.detection.thresholdPolarity='positive'

# Fiddle factor to add to the background; debugging only
config.processCcd.charImage.detection.adjustBackground=0.0

# Measure PSF? If False then keep the existing PSF model (which must exist) and use that model for all operations.
config.processCcd.charImage.doMeasurePsf=True

# Allow these measurement algorithms to fail without an exception
config.processCcd.charImage.measureApCorr.allowFailure=[]

# if true, only include terms where the sum of the x and y order is less than or equal to max(orderX, orderY)
config.processCcd.charImage.measureApCorr.fitConfig.triangular=True

# maximum Chebyshev function order in x
config.processCcd.charImage.measureApCorr.fitConfig.orderX=2

# maximum Chebyshev function order in y
config.processCcd.charImage.measureApCorr.fitConfig.orderY=2

# Number of standard devisations to clip at
config.processCcd.charImage.measureApCorr.numSigmaClip=3.0

# Multiplier of mean for maximum moments histogram range
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].histMomentMaxMultiplier=5.0

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].borderWidth=0

# specify the maximum psfFlux for good Psf Candidates (ignored if == 0)
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].fluxMax=0.0

# specify the minimum psfFlux for good Psf Candidates
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].fluxLim=12500.0

# candidate PSF's shapes must lie within this many sigma of the average shape
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].clumpNSigma=2.0

# Multiplier of mean for minimum moments histogram range
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].histMomentMinMultiplier=2.0

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolatedCenter', 'base_PixelFlags_flag_saturatedCenter', 'base_PixelFlags_flag_crCenter']

# Number of bins in moment histogram
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].histSize=64

# size of the kernel to create
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].kernelSize=21

# Maximum moment to consider
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].histMomentMax=100.0

# Clipping threshold for moments histogram range
config.processCcd.charImage.measureApCorr.starSelector['secondMoment'].histMomentClip=5.0

# specify the minimum psfFlux for good Psf Candidates
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].fluxMin=12500.0

# minimum width to include in histogram
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].widthMin=0.0

# specify the maximum psfFlux for good Psf Candidates (ignored if == 0)
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].fluxMax=0.0

# maximum width to include in histogram
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].widthMax=10.0

# Keep objects within this many sigma of cluster 0's median
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].nSigmaClip=2.0

# Name of field in Source to use for flux measurement
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].sourceFluxField='base_GaussianFlux_flux'

# Standard deviation of width allowed to be interpreted as good stars
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].widthStdAllowed=0.15

# size of the kernel to create
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].kernelSize=21

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolatedCenter', 'base_PixelFlags_flag_saturatedCenter', 'base_PixelFlags_flag_crCenter', 'base_PixelFlags_flag_bad', 'base_PixelFlags_flag_interpolated']

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measureApCorr.starSelector['objectSize'].borderWidth=0

# Max number of bad pixels 
config.processCcd.charImage.measureApCorr.starSelector['psfex'].maxbad=0

# Name of photometric flux key 
config.processCcd.charImage.measureApCorr.starSelector['psfex'].fluxName='base_PsfFlux'

# Minimum S/N for candidates
config.processCcd.charImage.measureApCorr.starSelector['psfex'].minsn=100.0

# Allowed FWHM variability (1.0 = 100%)
config.processCcd.charImage.measureApCorr.starSelector['psfex'].maxFwhmVariability=0.2

# Minimum allowed FWHM 
config.processCcd.charImage.measureApCorr.starSelector['psfex'].maxFwhm=10.0

# Name of phot. flux err. key
config.processCcd.charImage.measureApCorr.starSelector['psfex'].fluxErrName=''

# size of the kernel to create
config.processCcd.charImage.measureApCorr.starSelector['psfex'].kernelSize=21

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measureApCorr.starSelector['psfex'].borderWidth=0

# Filter bad pixels? 
config.processCcd.charImage.measureApCorr.starSelector['psfex'].maxbadflag=True

# Maximum (A-B)/(A+B) 
config.processCcd.charImage.measureApCorr.starSelector['psfex'].maxellip=0.3

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measureApCorr.starSelector['psfex'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_saturatedCenter', 'base_PixelFlags_flag_crCenter', 'base_PixelFlags_flag_bad', 'base_PixelFlags_flag_suspectCenter', 'base_PsfFlux_flag']

# Maximum allowed FWHM 
config.processCcd.charImage.measureApCorr.starSelector['psfex'].minFwhm=2.0

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measureApCorr.starSelector['flagged'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolatedCenter', 'base_PixelFlags_flag_saturatedCenter', 'base_PixelFlags_flag_crCenter', 'base_PixelFlags_flag_bad', 'base_PixelFlags_flag_interpolated']

# size of the kernel to create
config.processCcd.charImage.measureApCorr.starSelector['flagged'].kernelSize=21

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measureApCorr.starSelector['flagged'].borderWidth=0

# Name of a flag field that is True for stars that should be used.
config.processCcd.charImage.measureApCorr.starSelector['flagged'].field='calib_psfUsed'

# size of the kernel to create
config.processCcd.charImage.measureApCorr.starSelector['catalog'].kernelSize=21

# List of flags which cause a source to be rejected as bad
config.processCcd.charImage.measureApCorr.starSelector['catalog'].badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolatedCenter', 'base_PixelFlags_flag_saturatedCenter']

# specify the maximum psfFlux for good Psf Candidates (ignored if == 0)
# 	Valid Range = [0.0,inf)
config.processCcd.charImage.measureApCorr.starSelector['catalog'].fluxMax=0.0

# specify the minimum psfFlux for good Psf Candidates
# 	Valid Range = [0.0,inf)
config.processCcd.charImage.measureApCorr.starSelector['catalog'].fluxLim=0.0

# number of pixels to ignore around the edge of PSF candidate postage stamps
config.processCcd.charImage.measureApCorr.starSelector['catalog'].borderWidth=0

config.processCcd.charImage.measureApCorr.starSelector.name='flagged'
# Minimum number of degrees of freedom (# of valid data points - # of parameters); if this is exceeded, the order of the fit is decreased (in both dimensions), and if we can't decrease it enough, we'll raise ValueError.
# 	Valid Range = [1,inf)
config.processCcd.charImage.measureApCorr.minDegreesOfFreedom=1

# Number of iterations for sigma clipping
config.processCcd.charImage.measureApCorr.numIter=4

# Field name prefix for the flux other measurements should be aperture corrected to match
config.processCcd.charImage.measureApCorr.refFluxName='slot_CalibFlux'

# Save calibration results?
config.processCcd.calibrate.doWrite=True

# Run subtask to apply aperture correction
config.processCcd.calibrate.doApCorr=True

# Fields to copy from the icSource catalog to the output catalog for matching sources Any missing fields will trigger a RuntimeError exception. Ignored if icSourceCat is not provided.
config.processCcd.calibrate.icSourceFieldsToCopy=['calib_psfCandidate', 'calib_psfUsed', 'calib_psfReserved']

# Match radius for matching icSourceCat objects to sourceCat objects (pixels)
config.processCcd.calibrate.matchRadiusPix=3.0

# the maximum match distance is set to  mean_match_distance + matchDistanceSigma*std_dev_match_distance; ignored if not fitting a WCS
# 	Valid Range = [0,inf)
config.processCcd.calibrate.photoCal.matchDistanceSigma=2.0

# maximum sigma to use when clipping
config.processCcd.calibrate.photoCal.sigmaMax=0.25

# Additional magnitude uncertainty to be added in quadrature with measurement errors.
# 	Valid Range = [0.0,inf)
config.processCcd.calibrate.photoCal.magErrFloor=0.0

# Apply photometric color terms to reference stars? One of:
# None: apply if colorterms and photoCatName are not None;
#       fail if color term data is not available for the specified ref catalog and filter.
# True: always apply colorterms; fail if color term data is not available for the
#       specified reference catalog and filter.
# False: do not apply.
config.processCcd.calibrate.photoCal.applyColorTerms=True

# List of source flag fields that must be set for a source to be used.
config.processCcd.calibrate.photoCal.goodFlags=[]

# Minimum number of matched pairs; see also minFracMatchedPairs
# 	Valid Range = [2,inf)
config.processCcd.calibrate.photoCal.matcher.minMatchedPairs=30

# Allowed non-perpendicularity of x and y (degree)
# 	Valid Range = [-inf,45.0)
config.processCcd.calibrate.photoCal.matcher.allowedNonperpDeg=3.0

# maximum determinant of linear transformation matrix for a usable solution
config.processCcd.calibrate.photoCal.matcher.maxDeterminant=0.02

# Type of source flux; typically one of Ap or Psf
config.processCcd.calibrate.photoCal.matcher.sourceFluxType='Ap'

# Minimum allowed signal-to-noise ratio for sources used for matching (in the flux specified by sourceFluxType); <=0 for no limit
config.processCcd.calibrate.photoCal.matcher.minSnr=40.0

# number of points to define a shape for matching
config.processCcd.calibrate.photoCal.matcher.numPointsForShape=6

# Number of bright stars to use
# 	Valid Range = [2,inf)
config.processCcd.calibrate.photoCal.matcher.numBrightStars=50

# Minimum number of matched pairs as a fraction of the smaller of the number of reference stars or the number of good sources; the actual minimum is the smaller of this value or minMatchedPairs
# 	Valid Range = [0,1)
config.processCcd.calibrate.photoCal.matcher.minFracMatchedPairs=0.3

# Maximum allowed shift of WCS, due to matching (pixel)
# 	Valid Range = [-inf,4000)
config.processCcd.calibrate.photoCal.matcher.maxOffsetPix=300

# Rotation angle allowed between sources and position reference objects (degrees)
# 	Valid Range = [-inf,6.0)
config.processCcd.calibrate.photoCal.matcher.maxRotationDeg=1.0

# Maximum separation between reference objects and sources beyond which they will not be considered a match (arcsec)
# 	Valid Range = [0,inf)
config.processCcd.calibrate.photoCal.matcher.maxMatchDistArcSec=3.0

# Name of photometric reference catalog; used to select a color term dict in colorterms. see also applyColorTerms
config.processCcd.calibrate.photoCal.photoCatName='sdss-dr9-fink-v5b'

# clip at nSigma
config.processCcd.calibrate.photoCal.nSigma=3.0

# Write a field name astrom_usedByPhotoCal to the schema
config.processCcd.calibrate.photoCal.doWriteOutput=True

# number of iterations
config.processCcd.calibrate.photoCal.nIter=20

# Don't use objects fainter than this magnitude
config.processCcd.calibrate.photoCal.magLimit=22.0

# Name of the source flux field to use.  The associated flag field
# ('<name>_flags') will be implicitly included in badFlags.
config.processCcd.calibrate.photoCal.fluxField='slot_CalibFlux_flux'

# List of source flag fields that will cause a source to be rejected when they are set.
config.processCcd.calibrate.photoCal.badFlags=['base_PixelFlags_flag_edge', 'base_PixelFlags_flag_interpolated', 'base_PixelFlags_flag_saturated']

# Use the extendedness parameter to select objects to use in photometric calibration?
# This applies only to the sources detected on the exposure, not the reference catalog
config.processCcd.calibrate.photoCal.doSelectUnresolved=True

config.processCcd.calibrate.photoCal.colorterms.data={}
config.processCcd.calibrate.photoCal.colorterms.data['hsc*']=lsst.pipe.tasks.colorterms.ColortermDict()
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data={}
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['r']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['r'].c1=0.0

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['r'].secondary='r'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['r'].c2=0.0

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['r'].primary='r'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['r'].c0=0.0

config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['z']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['z'].c1=0.0

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['z'].secondary='z'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['z'].c2=0.0

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['z'].primary='z'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['z'].c0=0.0

config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['g']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['g'].c1=0.0

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['g'].secondary='g'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['g'].c2=0.0

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['g'].primary='g'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['g'].c0=0.0

config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['y']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['y'].c1=0.0

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['y'].secondary='y'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['y'].c2=0.0

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['y'].primary='y'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['y'].c0=0.0

config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['i']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['i'].c1=0.0

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['i'].secondary='i'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['i'].c2=0.0

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['i'].primary='i'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['hsc*'].data['i'].c0=0.0

config.processCcd.calibrate.photoCal.colorterms.data['sdss*']=lsst.pipe.tasks.colorterms.ColortermDict()
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data={}
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['y']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['y'].c1=0.35652971

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['y'].secondary='i'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['y'].c2=0.00574408

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['y'].primary='z'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['y'].c0=0.01739708

config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r'].c1=0.01284177

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r'].secondary='i'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r'].c2=-0.03068248

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r'].primary='r'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r'].c0=0.0023181

config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['z']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['z'].c1=0.01353969

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['z'].secondary='i'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['z'].c2=0.01479369

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['z'].primary='z'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['z'].c0=-0.0068062

config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['g']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['g'].c1=-0.08366937

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['g'].secondary='r'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['g'].c2=-0.00726883

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['g'].primary='g'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['g'].c0=-0.00816446

config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i2']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i2'].c1=-0.20739606

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i2'].secondary='z'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i2'].c2=-0.01067212

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i2'].primary='i'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i2'].c0=0.00124676

config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N921']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N921'].c1=0.0986353

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N921'].secondary='i'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N921'].c2=-0.05451118

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N921'].primary='z'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N921'].c0=0.00752972

config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r2']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r2'].c1=-0.00830543

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r2'].secondary='i'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r2'].c2=-0.0284842

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r2'].primary='r'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['r2'].c0=0.00074087

config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i'].c1=-0.16922042

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i'].secondary='z'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i'].c2=-0.01374245

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i'].primary='i'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['i'].c0=0.00130204

config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N816']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N816'].c1=-0.63558358

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N816'].secondary='z'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N816'].c2=-0.05474862

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N816'].primary='i'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['sdss*'].data['N816'].c0=0.00927133

config.processCcd.calibrate.photoCal.colorterms.data['ps1*']=lsst.pipe.tasks.colorterms.ColortermDict()
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data={}
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['y']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['y'].c1=0.14747401

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['y'].secondary='z'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['y'].c2=0.02880125

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['y'].primary='y'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['y'].c0=-0.00156858

config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r'].c1=0.02093734

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r'].secondary='i'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r'].c2=-0.01877566

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r'].primary='r'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r'].c0=0.00279757

config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['z']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['z'].c1=-0.28840221

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['z'].secondary='y'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['z'].c2=-0.00316369

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['z'].primary='z'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['z'].c0=-0.00907517

config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['g']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['g'].c1=0.06508481

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['g'].secondary='r'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['g'].c2=-0.0151057

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['g'].primary='g'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['g'].c0=0.00730066

config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i2']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i2'].c1=-0.18483562

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i2'].secondary='z'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i2'].c2=-0.02675511

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i2'].primary='i'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i2'].c0=0.00180361

config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N921']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N921'].c1=-0.59278367

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N921'].secondary='y'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N921'].c2=-0.25059679

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N921'].primary='z'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N921'].c0=0.00142051

config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r2']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r2'].c1=3.996e-05

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r2'].secondary='i'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r2'].c2=-0.01667794

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r2'].primary='r'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['r2'].c0=0.0011769

config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i'].c1=-0.13944659

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i'].secondary='z'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i'].c2=-0.03034094

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i'].primary='i'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['i'].c0=0.00166891

config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N816']=lsst.pipe.tasks.colorterms.Colorterm()
# First-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N816'].c1=-0.68757034

# name of secondary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N816'].secondary='z'

# Second-order parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N816'].c2=-0.10781564

# name of primary filter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N816'].primary='i'

# Constant parameter
config.processCcd.calibrate.photoCal.colorterms.data['ps1*'].data['N816'].c0=0.01191062

# use median instead of mean to compute zeropoint
config.processCcd.calibrate.photoCal.useMedian=True

# Mask planes with the corresponding limit on the fraction of masked pixels. Sources violating this limit will not be deblended.
config.processCcd.calibrate.deblend.maskLimits={'NO_DATA': 0.25}

# Chi-squared per DOF cut for deciding a source is PSF during deblending (shifted PSF model)
config.processCcd.calibrate.deblend.psfChisq2=1.5

# Only deblend the brightest maxNumberOfPeaks peaks in the parent (<= 0: unlimited)
config.processCcd.calibrate.deblend.maxNumberOfPeaks=0

# Footprints smaller in width or height than this value will be ignored; minimum of 2 due to PSF gradient calculation.
# 	Valid Range = [2,inf)
config.processCcd.calibrate.deblend.tinyFootprintSize=2

# When splitting stray flux, clip fractions below this value to zero.
config.processCcd.calibrate.deblend.clipStrayFluxFraction=0.001

# Minimum axis ratio for footprints before they are ignored as large; non-positive means no threshold applied
config.processCcd.calibrate.deblend.minFootprintAxisRatio=0.0

# Maximum area for footprints before they are ignored as large; non-positive means no threshold applied
config.processCcd.calibrate.deblend.maxFootprintArea=10000

# If True, catch exceptions thrown by the deblender, log them, and set a flag on the parent, instead of letting them propagate up
config.processCcd.calibrate.deblend.catchFailures=False

# What to do when a peak to be deblended is close to the edge of the image
# Allowed values:
# 	noclip	Ignore the edge when building the symmetric template.
# 	ramp	Ramp down flux at the image edge by the PSF
# 	clip	Clip the template at the edge AND the mirror of the edge.
# 	None	Field is optional
# 
config.processCcd.calibrate.deblend.edgeHandling='ramp'

# Chi-squared per DOF cut for deciding a source is a PSF during deblending (shifted PSF model #2)
config.processCcd.calibrate.deblend.psfChisq2b=1.5

# Maximum linear dimension for footprints before they are ignored as large; non-positive means no threshold applied
config.processCcd.calibrate.deblend.maxFootprintSize=0

# If true, a least-squares fit of the templates will be done to the full image. The templates will be re-weighted based on this fit.
config.processCcd.calibrate.deblend.weightTemplates=False

# Guarantee that all peaks produce a child source.
config.processCcd.calibrate.deblend.propagateAllPeaks=False

# Try to remove similar templates?
config.processCcd.calibrate.deblend.removeDegenerateTemplates=False

# If the dot product between two templates is larger than this value, we consider them to be describing the same object (i.e. they are degenerate).  If one of the objects has been labeled as a PSF it will be removed, otherwise the template with the lowest value will be removed.
config.processCcd.calibrate.deblend.maxTempDotProd=0.5

# Mask planes to ignore when performing statistics
config.processCcd.calibrate.deblend.maskPlanes=['SAT', 'INTRP', 'NO_DATA']

# When the deblender should attribute stray flux to point sources
# Allowed values:
# 	None	Field is optional
# 	always	Always
# 	necessary	When there is not an extended object in the footprint
# 	never	Never; stray flux will not be attributed to any deblended child if the deblender thinks all peaks look like point sources
# 
config.processCcd.calibrate.deblend.strayFluxToPointSources='necessary'

# Assign stray flux (not claimed by any child in the deblender) to deblend children.
config.processCcd.calibrate.deblend.assignStrayFlux=True

# Chi-squared per DOF cut for deciding a source is a PSF during deblending (un-shifted PSF model)
config.processCcd.calibrate.deblend.psfChisq1=1.5

# Mask name for footprints not deblended, or None
config.processCcd.calibrate.deblend.notDeblendedMask='NOT_DEBLENDED'

# How to split flux among peaks
# Allowed values:
# 	r-to-footprint	~ 1/(1+R^2) to the closest pixel in the footprint.  CAUTION: this can be computationally expensive on large footprints!
# 	r-to-peak	~ 1/(1+R^2) to the peak
# 	nearest-footprint	Assign 100% to the nearest footprint (using L-1 norm aka Manhattan distance)
# 	trim	Shrink the parent footprint to pixels that are not assigned to children
# 	None	Field is optional
# 
config.processCcd.calibrate.deblend.strayFluxRule='trim'

# Default reference catalog filter to use if filter not specified in exposure; if blank then filter must be specified in exposure
config.processCcd.calibrate.astromRefObjLoader.defaultFilter=''

# Mapping of camera filter name: reference catalog filter name; each reference filter must exist
config.processCcd.calibrate.astromRefObjLoader.filterMap={'y': 'z', 'i2': 'i', 'N387': 'g', 'N515': 'g', 'N816': 'i', 'N1010': 'z', 'N921': 'z', 'r2': 'r'}

# Padding to add to 4 all edges of the bounding box (pixels)
# 	Valid Range = [0,inf)
config.processCcd.calibrate.astromRefObjLoader.pixelMargin=50

# the maximum match distance is set to  mean_match_distance + matchDistanceSigma*std_dev_match_distance; ignored if not fitting a WCS
# 	Valid Range = [0,inf)
config.processCcd.calibrate.astrometry.matchDistanceSigma=2.0

# Minimum number of matched pairs; see also minFracMatchedPairs
# 	Valid Range = [2,inf)
config.processCcd.calibrate.astrometry.matcher.minMatchedPairs=30

# Allowed non-perpendicularity of x and y (degree)
# 	Valid Range = [-inf,45.0)
config.processCcd.calibrate.astrometry.matcher.allowedNonperpDeg=0.2

# maximum determinant of linear transformation matrix for a usable solution
config.processCcd.calibrate.astrometry.matcher.maxDeterminant=0.02

# Type of source flux; typically one of Ap or Psf
config.processCcd.calibrate.astrometry.matcher.sourceFluxType='Psf'

# Minimum allowed signal-to-noise ratio for sources used for matching (in the flux specified by sourceFluxType); <=0 for no limit
config.processCcd.calibrate.astrometry.matcher.minSnr=40.0

# number of points to define a shape for matching
config.processCcd.calibrate.astrometry.matcher.numPointsForShape=6

# Number of bright stars to use
# 	Valid Range = [2,inf)
config.processCcd.calibrate.astrometry.matcher.numBrightStars=50

# Minimum number of matched pairs as a fraction of the smaller of the number of reference stars or the number of good sources; the actual minimum is the smaller of this value or minMatchedPairs
# 	Valid Range = [0,1)
config.processCcd.calibrate.astrometry.matcher.minFracMatchedPairs=0.3

# Maximum allowed shift of WCS, due to matching (pixel)
# 	Valid Range = [-inf,4000)
config.processCcd.calibrate.astrometry.matcher.maxOffsetPix=750

# Rotation angle allowed between sources and position reference objects (degrees)
# 	Valid Range = [-inf,6.0)
config.processCcd.calibrate.astrometry.matcher.maxRotationDeg=1.145916

# Maximum separation between reference objects and sources beyond which they will not be considered a match (arcsec)
# 	Valid Range = [0,inf)
config.processCcd.calibrate.astrometry.matcher.maxMatchDistArcSec=2.0

# maximum number of iterations of match sources and fit WCSignored if not fitting a WCS
# 	Valid Range = [1,inf)
config.processCcd.calibrate.astrometry.maxIter=3

# If True then load reference objects and match sources but do not fit a WCS;  this simply controls whether 'run' calls 'solve' or 'loadAndMatch'
config.processCcd.calibrate.astrometry.forceKnownWcs=False

# the match distance below which further iteration is pointless (arcsec); ignored if not fitting a WCS
# 	Valid Range = [0,inf)
config.processCcd.calibrate.astrometry.minMatchDistanceArcSec=0.001

# number of rejection iterations
# 	Valid Range = [0,inf)
config.processCcd.calibrate.astrometry.wcsFitter.numRejIter=3

# number of iterations of fitter (which fits X and Y separately, and so benefits from a few iterations
# 	Valid Range = [1,inf)
config.processCcd.calibrate.astrometry.wcsFitter.numIter=3

# maximum median scatter of a WCS fit beyond which the fit fails (arcsec); be generous, as this is only intended to catch catastrophic failures
# 	Valid Range = [0,inf)
config.processCcd.calibrate.astrometry.wcsFitter.maxScatterArcsec=10.0

# order of SIP polynomial
# 	Valid Range = [0,inf)
config.processCcd.calibrate.astrometry.wcsFitter.order=3

# Number of standard deviations for clipping level
# 	Valid Range = [0.0,inf)
config.processCcd.calibrate.astrometry.wcsFitter.rejSigma=3.0

# Perform astrometric calibration?
config.processCcd.calibrate.doAstrometry=True

# flux measurement algorithms in getApCorrNameSet() to ignore; if a name is listed that does not appear in getApCorrNameSet() then a warning is logged
config.processCcd.calibrate.applyApCorr.ignoreList=[]

# flux measurement algorithms to be aperture-corrected by reference to another algorithm; this is a mapping alg1:alg2, where 'alg1' is the algorithm being corrected, and 'alg2' is the algorithm supplying the corrections
config.processCcd.calibrate.applyApCorr.proxies={}

# set the general failure flag for a flux when it cannot be aperture-corrected?
config.processCcd.calibrate.applyApCorr.doFlagApCorrFailures=True

# Strictness of Astropy unit compatibility check, can be 'raise', 'warn' or 'silent'
config.processCcd.calibrate.checkUnitsParseStrict='raise'

# Pixels should be grown as isotropically as possible (slower)
config.processCcd.calibrate.detection.isotropicGrow=True

# Threshold for footprints
# 	Valid Range = [0.0,inf)
config.processCcd.calibrate.detection.thresholdValue=5.0

# Grow detections to set the image mask bits, but return the original (not-grown) footprints
config.processCcd.calibrate.detection.returnOriginalFootprints=False

# specifies the desired flavor of Threshold
# Allowed values:
# 	variance	threshold applied to image variance
# 	stdev	threshold applied to image std deviation
# 	value	threshold applied to image value
# 	pixel_stdev	threshold applied to per-pixel std deviation
# 
config.processCcd.calibrate.detection.thresholdType='stdev'

# Include threshold relative to thresholdValue
# 	Valid Range = [0.0,inf)
config.processCcd.calibrate.detection.includeThresholdMultiplier=1.0

# Estimate the background again after final source detection?
config.processCcd.calibrate.detection.reEstimateBackground=True

# detected sources with fewer than the specified number of pixels will be ignored
# 	Valid Range = [0,inf)
config.processCcd.calibrate.detection.minPixels=1

# Names of mask planes to ignore while estimating the background
config.processCcd.calibrate.detection.tempLocalBackground.ignoredPixelMask=['BAD', 'EDGE', 'DETECTED', 'DETECTED_NEGATIVE', 'NO_DATA']

# type of statistic to use for grid points
# Allowed values:
# 	MEANCLIP	clipped mean
# 	MEAN	unclipped mean
# 	MEDIAN	median
# 	None	Field is optional
# 
config.processCcd.calibrate.detection.tempLocalBackground.statisticsProperty='MEANCLIP'

# how to interpolate the background values. This maps to an enum; see afw::math::Background
# Allowed values:
# 	AKIMA_SPLINE	higher-level nonlinear spline that is more robust to outliers
# 	CONSTANT	Use a single constant value
# 	None	Field is optional
# 	LINEAR	Use linear interpolation
# 	NATURAL_SPLINE	cubic spline with zero second derivative at endpoints
# 	NONE	No background estimation is to be attempted
# 
config.processCcd.calibrate.detection.tempLocalBackground.algorithm='AKIMA_SPLINE'

# how large a region of the sky should be used for each background point
# 	Valid Range = [1,inf)
config.processCcd.calibrate.detection.tempLocalBackground.binSize=64

# Approximation order in Y for background Chebyshev (valid only with useApprox=True)
config.processCcd.calibrate.detection.tempLocalBackground.approxOrderY=-1

# Use inverse variance weighting in calculation (valid only with useApprox=True)
config.processCcd.calibrate.detection.tempLocalBackground.weighting=True

# Ignore NaNs when estimating the background
config.processCcd.calibrate.detection.tempLocalBackground.isNanSafe=False

# Approximation order in X for background Chebyshev (valid only with useApprox=True)
config.processCcd.calibrate.detection.tempLocalBackground.approxOrderX=6

# behaviour if there are too few points in grid for requested interpolation style
# Allowed values:
# 	THROW_EXCEPTION	throw an exception if there are too few points
# 	None	Field is optional
# 	INCREASE_NXNYSAMPLE	Increase the number of samples used to make the interpolation grid.
# 	REDUCE_INTERP_ORDER	use an interpolation style with a lower order.
# 
config.processCcd.calibrate.detection.tempLocalBackground.undersampleStyle='REDUCE_INTERP_ORDER'

# Use Approximate (Chebyshev) to model background.
config.processCcd.calibrate.detection.tempLocalBackground.useApprox=False

# Grow detections by nSigmaToGrow * sigma; if 0 then do not grow
config.processCcd.calibrate.detection.nSigmaToGrow=2.4

# Names of mask planes to ignore while estimating the background
config.processCcd.calibrate.detection.background.ignoredPixelMask=['BAD', 'EDGE', 'DETECTED', 'DETECTED_NEGATIVE', 'NO_DATA']

# type of statistic to use for grid points
# Allowed values:
# 	MEANCLIP	clipped mean
# 	MEAN	unclipped mean
# 	MEDIAN	median
# 	None	Field is optional
# 
config.processCcd.calibrate.detection.background.statisticsProperty='MEANCLIP'

# how to interpolate the background values. This maps to an enum; see afw::math::Background
# Allowed values:
# 	AKIMA_SPLINE	higher-level nonlinear spline that is more robust to outliers
# 	CONSTANT	Use a single constant value
# 	None	Field is optional
# 	LINEAR	Use linear interpolation
# 	NATURAL_SPLINE	cubic spline with zero second derivative at endpoints
# 	NONE	No background estimation is to be attempted
# 
config.processCcd.calibrate.detection.background.algorithm='NATURAL_SPLINE'

# how large a region of the sky should be used for each background point
# 	Valid Range = [1,inf)
config.processCcd.calibrate.detection.background.binSize=128

# Approximation order in Y for background Chebyshev (valid only with useApprox=True)
config.processCcd.calibrate.detection.background.approxOrderY=-1

# Use inverse variance weighting in calculation (valid only with useApprox=True)
config.processCcd.calibrate.detection.background.weighting=True

# Ignore NaNs when estimating the background
config.processCcd.calibrate.detection.background.isNanSafe=False

# Approximation order in X for background Chebyshev (valid only with useApprox=True)
config.processCcd.calibrate.detection.background.approxOrderX=6

# behaviour if there are too few points in grid for requested interpolation style
# Allowed values:
# 	THROW_EXCEPTION	throw an exception if there are too few points
# 	None	Field is optional
# 	INCREASE_NXNYSAMPLE	Increase the number of samples used to make the interpolation grid.
# 	REDUCE_INTERP_ORDER	use an interpolation style with a lower order.
# 
config.processCcd.calibrate.detection.background.undersampleStyle='REDUCE_INTERP_ORDER'

# Use Approximate (Chebyshev) to model background.
config.processCcd.calibrate.detection.background.useApprox=True

# Do temporary interpolated background subtraction before footprint detection?
config.processCcd.calibrate.detection.doTempLocalBackground=False

# specifies whether to detect positive, or negative sources, or both
# Allowed values:
# 	positive	detect only positive sources
# 	negative	detect only negative sources
# 	both	detect both positive and negative sources
# 
config.processCcd.calibrate.detection.thresholdPolarity='positive'

# Fiddle factor to add to the background; debugging only
config.processCcd.calibrate.detection.adjustBackground=0.0

# Run deblender input exposure
config.processCcd.calibrate.doDeblend=True

# Include HeavyFootprint data in source table? If false then heavy footprints are saved as normal footprints, which saves some space
config.processCcd.calibrate.doWriteHeavyFootprintsInSources=True

# Raise an exception if photoCal fails? Ignored if doPhotoCal false.
config.processCcd.calibrate.requirePhotoCal=True

# correction factor for modelFlux error
config.processCcd.calibrate.catalogCalculation.plugins['base_ClassificationExtendedness'].modelErrFactor=0.0

# correction factor for psfFlux error
config.processCcd.calibrate.catalogCalculation.plugins['base_ClassificationExtendedness'].psfErrFactor=0.0

# critical ratio of model to psf flux
config.processCcd.calibrate.catalogCalculation.plugins['base_ClassificationExtendedness'].fluxRatio=0.95

config.processCcd.calibrate.catalogCalculation.plugins.names=['base_ClassificationExtendedness']
# Field name for number of deblend children
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeLinear'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeLinear'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeLinear'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_InputCount'].doMeasure=True

# Whether to also compute the shape of the PSF model
config.processCcd.calibrate.measurement.undeblended['base_SdssShape'].doMeasurePsf=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_SdssShape'].doMeasure=True

# Convergence tolerance for FWHM
config.processCcd.calibrate.measurement.undeblended['base_SdssShape'].tol2=9.999999747378752e-05

# Maximum centroid shift, limited to 2-10
config.processCcd.calibrate.measurement.undeblended['base_SdssShape'].maxShift=0.0

# Maximum number of iterations
config.processCcd.calibrate.measurement.undeblended['base_SdssShape'].maxIter=100

# Convergence tolerance for e1,e2
config.processCcd.calibrate.measurement.undeblended['base_SdssShape'].tol1=9.999999747378752e-06

# Additional value to add to background
config.processCcd.calibrate.measurement.undeblended['base_SdssShape'].background=0.0

# Nominal pixel size (arcsec)
config.processCcd.calibrate.measurement.undeblended['base_Jacobian'].pixelScale=0.5

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_Jacobian'].doMeasure=True

# Maximum radius (in pixels) for which the sinc algorithm should be used instead of the faster naive algorithm.  For elliptical apertures, this is the minor axis radius.
config.processCcd.calibrate.measurement.undeblended['base_CircularApertureFlux'].maxSincRadius=10.0

# Warping kernel used to shift Sinc photometry coefficients to different center positions
config.processCcd.calibrate.measurement.undeblended['base_CircularApertureFlux'].shiftKernel='lanczos5'

# Radius (in pixels) of apertures.
config.processCcd.calibrate.measurement.undeblended['base_CircularApertureFlux'].radii=[3.0, 4.5, 6.0, 9.0, 12.0, 17.0, 25.0, 35.0, 50.0, 70.0]

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_CircularApertureFlux'].doMeasure=True

# Shapelet order of outer expansion (0 == Gaussian)
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].outerOrder=1

# Shapelet order of inner expansion (0 == Gaussian)
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].innerOrder=2

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].doMeasure=True

# Initial outer radius divided by inner radius
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].radiusRatio=2.0

# Don't allow the semi-major radius of any component to go above this fraction of the PSF image width
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].maxRadiusBoxFraction=0.4

# Don't allow the semi-minor radius of any component to drop below this value (pixels)
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].minRadius=1.0

# Don't allow the determinant radii of the two components to differ by less than this (pixels)
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].minRadiusDiff=0.5

# Initial outer Gaussian peak height divided by inner Gaussian peak height
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].peakRatio=0.1

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowReductionRatio=0.75

# Grow the initial fit ellipses by this factor before comparing with the Kron/Footprint region
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].region.nPsfSigmaGrow=2.0

# Mask planes that indicate pixels that should be ignored in the fit.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].region.badMaskPlanes=['EDGE', 'SAT', 'BAD', 'NO_DATA']

# Use this multiple of the initial fit ellipse then grow by the PSF width to determine the maximum final fit region size.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].region.nFitRadiiMax=3.0

# Maximum fraction of pixels that may be ignored due to masks; more than this and we don't even try.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].region.maxBadPixelFraction=0.1

# Use this multiple of the Kron ellipse to set the fit region (for the final fit region, subject to the nFitRadiiMin and nFitRadiiMax constraints).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].region.nKronRadii=1.5

# Use this multiple of the initial fit ellipse then grow by the PSF width to determine the minimum final fit region size.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].region.nFitRadiiMin=1.0

# If the Kron radius is less than this multiple of the PSF width, ignore it and fall back to a PSF-oriented ellipse scaled to match the area of the footprint or this radius (whichever is larger).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].region.nPsfSigmaMin=4.0

# Abort if the fit region grows beyond this many pixels.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].region.maxArea=100000

# Field name prefix of the Shapelet PSF approximation used to convolve the galaxy model; must contain a set of fields matching the schema defined by shapelet.MultiShapeletFunctionKey.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].psfName='modelfit_DoubleShapeletPsfApprox'

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].doMeasure=True

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.priorName=''

# Whether to record the time spent in this stage
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.profileName='lux'

# Number of Gaussian used to approximate the profile
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.nComponents=3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.gradientThreshold=0.01

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.minTrustRadiusThreshold=0.01

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.usePixelWeights=True

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].initial.linearPriorConfig.ellipticityMaxInner=2.0

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.priorName=''

# Whether to record the time spent in this stage
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.profileName='lux'

# Number of Gaussian used to approximate the profile
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.nComponents=6

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.maxOuterIterations=250

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.usePixelWeights=False

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].exp.linearPriorConfig.ellipticityMaxInner=2.0

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.priorName=''

# Whether to record the time spent in this stage
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.profileName='luv'

# Number of Gaussian used to approximate the profile
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.nComponents=8

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.usePixelWeights=False

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].dev.linearPriorConfig.ellipticityMaxInner=2.0

# Minimum initial radius in pixels (used to regularize initial moments-based PSF deconvolution)
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].minInitialRadius=0.1

# If the 2nd-moments shape used to initialize the fit failed, use the PSF moments multiplied by this.  If <= 0.0, abort the fit early instead.
config.processCcd.calibrate.measurement.undeblended['modelfit_CModel'].fallbackInitialMomentsPsfFactor=1.5

# Do check that the centroid is contained in footprint.
config.processCcd.calibrate.measurement.undeblended['base_GaussianCentroid'].doFootprintCheck=True

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.calibrate.measurement.undeblended['base_GaussianCentroid'].maxDistToPeak=-1.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_GaussianCentroid'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_FPPosition'].doMeasure=True

# Scaling factor of PSF FWHM for aperture radius.
config.processCcd.calibrate.measurement.undeblended['base_ScaledApertureFlux'].scale=3.14

# Warping kernel used to shift Sinc photometry coefficients to different center positions
config.processCcd.calibrate.measurement.undeblended['base_ScaledApertureFlux'].shiftKernel='lanczos5'

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_ScaledApertureFlux'].doMeasure=True

# Mask planes used to reject bad pixels.
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmSourceMoments'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmSourceMoments'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmPsfMoments'].doMeasure=True

# List of mask planes to be searched for which occur anywhere within a footprint. If any of the planes are found they will have a corresponding pixel flag set.
config.processCcd.calibrate.measurement.undeblended['base_PixelFlags'].masksFpAnywhere=[]

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_PixelFlags'].doMeasure=True

# List of mask planes to be searched for which occur in the center of a footprint. If any of the planes are found they will have a corresponding pixel flag set.
config.processCcd.calibrate.measurement.undeblended['base_PixelFlags'].masksFpCenter=[]

# FIXME! NEVER DOCUMENTED!
config.processCcd.calibrate.measurement.undeblended['base_GaussianFlux'].background=0.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_GaussianFlux'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_SkyCoord'].doMeasure=True

# Scale factor to apply to shape for aperture
config.processCcd.calibrate.measurement.undeblended['base_Variance'].scale=5.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_Variance'].doMeasure=True

# Mask planes to ignore
config.processCcd.calibrate.measurement.undeblended['base_Variance'].mask=['DETECTED', 'DETECTED_NEGATIVE', 'BAD', 'SAT']

# Whether to compute quantities related to the Gaussian-weighted shape
config.processCcd.calibrate.measurement.undeblended['base_Blendedness'].doShape=True

# Whether to compute quantities related to the Gaussian-weighted flux
config.processCcd.calibrate.measurement.undeblended['base_Blendedness'].doFlux=True

# Whether to compute HeavyFootprint dot products (the old deblend.blendedness parameter)
config.processCcd.calibrate.measurement.undeblended['base_Blendedness'].doOld=True

# Radius factor that sets the maximum extent of the weight function (and hence the flux measurements)
config.processCcd.calibrate.measurement.undeblended['base_Blendedness'].nSigmaWeightMax=3.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_Blendedness'].doMeasure=True

# Field name for number of deblend children
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeRegauss'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeRegauss'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeRegauss'].doMeasure=True

# Name of warping kernel (e.g. "lanczos4") used to compute the peak
config.processCcd.calibrate.measurement.undeblended['base_PeakLikelihoodFlux'].warpingKernelName='lanczos4'

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_PeakLikelihoodFlux'].doMeasure=True

# a sequence of model names indicating which models should be fit, and their order
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].sequence=['DoubleShapelet']

config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models={}
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.order=2

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.order=1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.order=4

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.order=4

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowReductionRatio=0.75

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['modelfit_GeneralShapeletPsfApprox'].doMeasure=True

# Field name for number of deblend children
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeKsb'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeKsb'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeKsb'].doMeasure=True

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.undeblended['base_PsfFlux'].badMaskPlanes=[]

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_PsfFlux'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_PeakCentroid'].doMeasure=True

# Do check that the centroid is contained in footprint.
config.processCcd.calibrate.measurement.undeblended['base_NaiveCentroid'].doFootprintCheck=True

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.calibrate.measurement.undeblended['base_NaiveCentroid'].maxDistToPeak=-1.0

# Value to subtract from the image pixel values
config.processCcd.calibrate.measurement.undeblended['base_NaiveCentroid'].background=0.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_NaiveCentroid'].doMeasure=True

# Field name for number of deblend children
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeBj'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeBj'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['ext_shapeHSM_HsmShapeBj'].doMeasure=True

# Do check that the centroid is contained in footprint.
config.processCcd.calibrate.measurement.undeblended['base_SdssCentroid'].doFootprintCheck=True

# if the peak's less than this insist on binning at least once
config.processCcd.calibrate.measurement.undeblended['base_SdssCentroid'].peakMin=-1.0

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.calibrate.measurement.undeblended['base_SdssCentroid'].maxDistToPeak=-1.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.undeblended['base_SdssCentroid'].doMeasure=True

# fiddle factor for adjusting the binning
config.processCcd.calibrate.measurement.undeblended['base_SdssCentroid'].wfac=1.5

# maximum allowed binning
config.processCcd.calibrate.measurement.undeblended['base_SdssCentroid'].binmax=16

config.processCcd.calibrate.measurement.undeblended.names=[]
# The seed multiplier value to use for random number generation
#    >= 1: set the seed deterministically based on exposureId
#       0: fall back to the afw.math.Random default constructor (which uses a seed value of 1)
config.processCcd.calibrate.measurement.noiseReplacer.noiseSeedMultiplier=1

# Add ann offset to the generated noise.
config.processCcd.calibrate.measurement.noiseReplacer.noiseOffset=0.0

# How to choose mean and variance of the Gaussian noise we generate?
# Allowed values:
# 	measure	Measure clipped mean and variance from the whole image
# 	variance	Mean = 0, variance = the image's variance
# 	meta	Mean = 0, variance = the "BGMEAN" metadata entry
# 
config.processCcd.calibrate.measurement.noiseReplacer.noiseSource='measure'

# the name of the algorithm used to set the source model flux slot
config.processCcd.calibrate.measurement.slots.modelFlux='base_GaussianFlux'

# the name of the flux measurement algorithm used for calibration
config.processCcd.calibrate.measurement.slots.calibFlux='base_CircularApertureFlux_12_0'

# the name of the algorithm used to set the source psf flux slot
config.processCcd.calibrate.measurement.slots.psfFlux='base_PsfFlux'

# the name of the centroiding algorithm used to set source x,y
config.processCcd.calibrate.measurement.slots.centroid='base_SdssCentroid'

# the name of the algorithm used to set the source aperture flux slot
config.processCcd.calibrate.measurement.slots.apFlux='base_CircularApertureFlux_12_0'

# the name of the algorithm used to set the source inst flux slot
config.processCcd.calibrate.measurement.slots.instFlux='base_GaussianFlux'

# the name of the algorithm used to set source moments parameters
config.processCcd.calibrate.measurement.slots.shape='ext_shapeHSM_HsmSourceMoments'

# Field name for number of deblend children
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeLinear'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeLinear'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeLinear'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_InputCount'].doMeasure=True

# Whether to also compute the shape of the PSF model
config.processCcd.calibrate.measurement.plugins['base_SdssShape'].doMeasurePsf=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_SdssShape'].doMeasure=True

# Convergence tolerance for FWHM
config.processCcd.calibrate.measurement.plugins['base_SdssShape'].tol2=9.999999747378752e-05

# Maximum centroid shift, limited to 2-10
config.processCcd.calibrate.measurement.plugins['base_SdssShape'].maxShift=0.0

# Maximum number of iterations
config.processCcd.calibrate.measurement.plugins['base_SdssShape'].maxIter=100

# Convergence tolerance for e1,e2
config.processCcd.calibrate.measurement.plugins['base_SdssShape'].tol1=9.999999747378752e-06

# Additional value to add to background
config.processCcd.calibrate.measurement.plugins['base_SdssShape'].background=0.0

# Nominal pixel size (arcsec)
config.processCcd.calibrate.measurement.plugins['base_Jacobian'].pixelScale=0.168

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_Jacobian'].doMeasure=True

# Maximum radius (in pixels) for which the sinc algorithm should be used instead of the faster naive algorithm.  For elliptical apertures, this is the minor axis radius.
config.processCcd.calibrate.measurement.plugins['base_CircularApertureFlux'].maxSincRadius=12.0

# Warping kernel used to shift Sinc photometry coefficients to different center positions
config.processCcd.calibrate.measurement.plugins['base_CircularApertureFlux'].shiftKernel='lanczos5'

# Radius (in pixels) of apertures.
config.processCcd.calibrate.measurement.plugins['base_CircularApertureFlux'].radii=[3.0, 4.5, 6.0, 9.0, 12.0, 17.0, 25.0, 35.0, 50.0, 70.0]

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_CircularApertureFlux'].doMeasure=True

# Shapelet order of outer expansion (0 == Gaussian)
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].outerOrder=1

# Shapelet order of inner expansion (0 == Gaussian)
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].innerOrder=2

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].doMeasure=True

# Initial outer radius divided by inner radius
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].radiusRatio=2.0

# Don't allow the semi-major radius of any component to go above this fraction of the PSF image width
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].maxRadiusBoxFraction=0.4

# Don't allow the semi-minor radius of any component to drop below this value (pixels)
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].minRadius=1.0

# Don't allow the determinant radii of the two components to differ by less than this (pixels)
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].minRadiusDiff=0.5

# Initial outer Gaussian peak height divided by inner Gaussian peak height
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].peakRatio=0.1

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_DoubleShapeletPsfApprox'].optimizer.trustRegionGrowReductionRatio=0.75

# Grow the initial fit ellipses by this factor before comparing with the Kron/Footprint region
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].region.nPsfSigmaGrow=2.0

# Mask planes that indicate pixels that should be ignored in the fit.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].region.badMaskPlanes=['EDGE', 'SAT', 'BAD', 'NO_DATA']

# Use this multiple of the initial fit ellipse then grow by the PSF width to determine the maximum final fit region size.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].region.nFitRadiiMax=3.0

# Maximum fraction of pixels that may be ignored due to masks; more than this and we don't even try.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].region.maxBadPixelFraction=0.1

# Use this multiple of the Kron ellipse to set the fit region (for the final fit region, subject to the nFitRadiiMin and nFitRadiiMax constraints).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].region.nKronRadii=1.5

# Use this multiple of the initial fit ellipse then grow by the PSF width to determine the minimum final fit region size.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].region.nFitRadiiMin=1.0

# If the Kron radius is less than this multiple of the PSF width, ignore it and fall back to a PSF-oriented ellipse scaled to match the area of the footprint or this radius (whichever is larger).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].region.nPsfSigmaMin=4.0

# Abort if the fit region grows beyond this many pixels.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].region.maxArea=100000

# Field name prefix of the Shapelet PSF approximation used to convolve the galaxy model; must contain a set of fields matching the schema defined by shapelet.MultiShapeletFunctionKey.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].psfName='modelfit_DoubleShapeletPsfApprox'

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].doMeasure=True

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.priorName=''

# Whether to record the time spent in this stage
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.profileName='lux'

# Number of Gaussian used to approximate the profile
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.nComponents=3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.gradientThreshold=0.01

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.minTrustRadiusThreshold=0.01

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.usePixelWeights=True

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].initial.linearPriorConfig.ellipticityMaxInner=2.0

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.priorName=''

# Whether to record the time spent in this stage
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.profileName='lux'

# Number of Gaussian used to approximate the profile
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.nComponents=6

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.maxOuterIterations=250

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.usePixelWeights=False

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].exp.linearPriorConfig.ellipticityMaxInner=2.0

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMinInner=-6.0

# Width of exponential ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.ellipticitySigma=0.3

# Minimum ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMinOuter=-6.001

# Number of degrees of freedom for the Student's T distribution on ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusNu=50.0

# Width of the Student's T distribution in ln(radius).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusSigma=0.45

# Softened core width for ellipticity distribution (conformal shear units).
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.ellipticityCore=0.001

# Mean of the Student's T distribution used for ln(radius) at large radius, and the transition point between a flat distribution and the Student's T.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.empiricalPriorConfig.logRadiusMu=-1.0

# Maximum radius used in approximating profile with Gaussians (0=default for this profile)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.maxRadius=0

# One of 'FILE', 'LINEAR', 'EMPIRICAL', or 'NONE', indicating whether the prior should be loaded from disk, created from one of the nested prior config/control objects, or None
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.priorSource='EMPIRICAL'

# Name of the Prior that defines the model to fit (a filename in $MEAS_MODELFIT_DIR/data, with no extension), if priorSource='FILE'.  Ignored for forced fitting.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.priorName=''

# Whether to record the time spent in this stage
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.doRecordTime=True

# Whether to record the steps the optimizer takes (or just the number, if running as a plugin)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.doRecordHistory=True

# Name of the shapelet.RadialProfile that defines the model to fit
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.profileName='luv'

# Number of Gaussian used to approximate the profile
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.nComponents=8

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.optimizer.trustRegionGrowReductionRatio=0.75

# Use per-pixel variances as weights in the nonlinear fit (the final linear fit for flux never uses per-pixel variances)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.usePixelWeights=False

# ln(radius) at which the softened cutoff begins towards the minimum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinInner=-6.0

# ln(radius) at which the softened cutoff begins towards the maximum
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMaxInner=3.0

# The ratio P(logRadiusMinInner)/P(logRadiusMaxInner)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinMaxRatio=1.0

# Maximum ln(radius)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMaxOuter=3.001

# Minimum ln(radius)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.logRadiusMinOuter=-6.001

# Maximum ellipticity magnitude (conformal shear units)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.ellipticityMaxOuter=2.001

# Ellipticity magnitude (conformal shear units) at which the softened cutoff begins
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].dev.linearPriorConfig.ellipticityMaxInner=2.0

# Minimum initial radius in pixels (used to regularize initial moments-based PSF deconvolution)
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].minInitialRadius=0.1

# If the 2nd-moments shape used to initialize the fit failed, use the PSF moments multiplied by this.  If <= 0.0, abort the fit early instead.
config.processCcd.calibrate.measurement.plugins['modelfit_CModel'].fallbackInitialMomentsPsfFactor=1.5

# Do check that the centroid is contained in footprint.
config.processCcd.calibrate.measurement.plugins['base_GaussianCentroid'].doFootprintCheck=True

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.calibrate.measurement.plugins['base_GaussianCentroid'].maxDistToPeak=-1.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_GaussianCentroid'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_FPPosition'].doMeasure=True

# Scaling factor of PSF FWHM for aperture radius.
config.processCcd.calibrate.measurement.plugins['base_ScaledApertureFlux'].scale=3.14

# Warping kernel used to shift Sinc photometry coefficients to different center positions
config.processCcd.calibrate.measurement.plugins['base_ScaledApertureFlux'].shiftKernel='lanczos5'

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_ScaledApertureFlux'].doMeasure=True

# Mask planes used to reject bad pixels.
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmSourceMoments'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmSourceMoments'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmPsfMoments'].doMeasure=True

# List of mask planes to be searched for which occur anywhere within a footprint. If any of the planes are found they will have a corresponding pixel flag set.
config.processCcd.calibrate.measurement.plugins['base_PixelFlags'].masksFpAnywhere=[]

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_PixelFlags'].doMeasure=True

# List of mask planes to be searched for which occur in the center of a footprint. If any of the planes are found they will have a corresponding pixel flag set.
config.processCcd.calibrate.measurement.plugins['base_PixelFlags'].masksFpCenter=[]

# FIXME! NEVER DOCUMENTED!
config.processCcd.calibrate.measurement.plugins['base_GaussianFlux'].background=0.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_GaussianFlux'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_SkyCoord'].doMeasure=True

# Scale factor to apply to shape for aperture
config.processCcd.calibrate.measurement.plugins['base_Variance'].scale=5.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_Variance'].doMeasure=True

# Mask planes to ignore
config.processCcd.calibrate.measurement.plugins['base_Variance'].mask=['DETECTED', 'DETECTED_NEGATIVE', 'BAD', 'SAT']

# Whether to compute quantities related to the Gaussian-weighted shape
config.processCcd.calibrate.measurement.plugins['base_Blendedness'].doShape=True

# Whether to compute quantities related to the Gaussian-weighted flux
config.processCcd.calibrate.measurement.plugins['base_Blendedness'].doFlux=True

# Whether to compute HeavyFootprint dot products (the old deblend.blendedness parameter)
config.processCcd.calibrate.measurement.plugins['base_Blendedness'].doOld=True

# Radius factor that sets the maximum extent of the weight function (and hence the flux measurements)
config.processCcd.calibrate.measurement.plugins['base_Blendedness'].nSigmaWeightMax=3.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_Blendedness'].doMeasure=True

# Field name for number of deblend children
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeRegauss'].deblendNChild='deblend_nChild'

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeRegauss'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeRegauss'].doMeasure=True

# Name of warping kernel (e.g. "lanczos4") used to compute the peak
config.processCcd.calibrate.measurement.plugins['base_PeakLikelihoodFlux'].warpingKernelName='lanczos4'

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_PeakLikelihoodFlux'].doMeasure=True

# a sequence of model names indicating which models should be fit, and their order
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].sequence=['DoubleShapelet']

config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models={}
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['SingleGaussian'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.order=2

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.order=1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleShapelet'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.order=4

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.order=4

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['Full'].optimizer.trustRegionGrowReductionRatio=0.75

config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian']=lsst.meas.modelfit.modelfitLib.GeneralPsfFitterConfig()
# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.radiusFactor=4.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].outer.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.radiusFactor=1.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].primary.ellipticityPriorSigma=0.3

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.radiusFactor=2.0

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.order=0

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].wings.ellipticityPriorSigma=0.3

# Default value for the noiseSigma parameter in GeneralPsfFitter.apply()
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].defaultNoiseSigma=0.001

# Sets the fiducial radius of this component relative to the 'primary radius' of the PSF: either the second-moments radius of the PSF image (in an initial fit), or the radius of the primary component in a previous fit.  Ignored if the previous fit included this component (as then we can just use that radius).
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.radiusFactor=0.5

# sigma (in pixels) in an isotropic 2-d Gaussian prior on the center of this shapelet component, relative to the center of the PSF image
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.positionPriorSigma=0.1

# shapelet order for this component; negative to disable this component completely
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.order=-1

# sigma in a Gaussian prior on ln(radius/fiducialRadius)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.radiusPriorSigma=0.5

# sigma in an isotropic 2-d Gaussian prior on the conformal-shear ellipticity eta
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].inner.ellipticityPriorSigma=0.3

# absolute step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffAbsStep=0.0

# relative step size used for numerical derivatives (added to other steps)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffRelStep=0.0

# value passed as the tolerance to solveTrustRegion
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionSolverTolerance=1e-08

# maximum number of steps
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.maxOuterIterations=500

# when increase the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowFactor=2.0

# step size (in units of trust radius) used for numerical derivatives (added to relative step)
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.numDiffTrustRadiusStep=0.1

# steps with length this fraction of the trust radius may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowStepFraction=0.8

# whether to save all iterations for debugging purposes
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.doSaveIterations=False

# If true, ignore the SR1 update term in the Hessian, resulting in a Levenberg-Marquardt-like method
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.noSR1Term=False

# Skip the SR1 update if |v||s| / (|v||s|) is less than this threshold
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.skipSR1UpdateThreshold=1e-08

# the initial trust region will be set to this value
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionInitialSize=1.0

# If the maximum of the gradient falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.gradientThreshold=1e-05

# steps with reduction ratio greater than this are accepted
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.stepAcceptThreshold=0.0

# If the trust radius falls below this threshold, consider the algorithm converged
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.minTrustRadiusThreshold=1e-05

# steps with reduction radio less than this will decrease the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionShrinkReductionRatio=0.25

# maximum number of iterations (i.e. function evaluations and trust region subproblems) per step
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.maxInnerIterations=20

# when reducing the trust region size, multiply the radius by this factor
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionShrinkFactor=0.3333333333333333

# steps with reduction radio greater than this may increase the trust radius
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].models['DoubleGaussian'].optimizer.trustRegionGrowReductionRatio=0.75

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['modelfit_GeneralShapeletPsfApprox'].doMeasure=True

# Field name for number of deblend children
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeKsb'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeKsb'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeKsb'].doMeasure=True

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.plugins['base_PsfFlux'].badMaskPlanes=[]

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_PsfFlux'].doMeasure=True

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_PeakCentroid'].doMeasure=True

# Do check that the centroid is contained in footprint.
config.processCcd.calibrate.measurement.plugins['base_NaiveCentroid'].doFootprintCheck=True

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.calibrate.measurement.plugins['base_NaiveCentroid'].maxDistToPeak=-1.0

# Value to subtract from the image pixel values
config.processCcd.calibrate.measurement.plugins['base_NaiveCentroid'].background=0.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_NaiveCentroid'].doMeasure=True

# Field name for number of deblend children
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeBj'].deblendNChild=''

# Mask planes that indicate pixels that should be excluded from the fit
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeBj'].badMaskPlanes=['BAD', 'SAT', 'INTRP']

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['ext_shapeHSM_HsmShapeBj'].doMeasure=True

# Do check that the centroid is contained in footprint.
config.processCcd.calibrate.measurement.plugins['base_SdssCentroid'].doFootprintCheck=True

# if the peak's less than this insist on binning at least once
config.processCcd.calibrate.measurement.plugins['base_SdssCentroid'].peakMin=-1.0

# If set > 0, Centroid Check also checks distance from footprint peak.
config.processCcd.calibrate.measurement.plugins['base_SdssCentroid'].maxDistToPeak=-1.0

# whether to run this plugin in single-object mode
config.processCcd.calibrate.measurement.plugins['base_SdssCentroid'].doMeasure=True

# fiddle factor for adjusting the binning
config.processCcd.calibrate.measurement.plugins['base_SdssCentroid'].wfac=1.5

# maximum allowed binning
config.processCcd.calibrate.measurement.plugins['base_SdssCentroid'].binmax=16

config.processCcd.calibrate.measurement.plugins.names=['base_SkyCoord', 'base_Variance', 'ext_shapeHSM_HsmSourceMoments', 'base_SdssShape', 'ext_shapeHSM_HsmShapeRegauss', 'base_CircularApertureFlux', 'base_Jacobian', 'base_GaussianCentroid', 'base_FPPosition', 'ext_shapeHSM_HsmPsfMoments', 'base_PsfFlux', 'base_NaiveCentroid', 'base_PixelFlags', 'base_GaussianFlux', 'base_SdssCentroid']
# Prefix to give undeblended plugins
config.processCcd.calibrate.measurement.undeblendedPrefix='undeblended_'

# When measuring, replace other detected footprints with noise?
config.processCcd.calibrate.measurement.doReplaceWithNoise=True

# Perform phometric calibration?
config.processCcd.calibrate.doPhotoCal=True

# Raise an exception if astrometry fails? Ignored if doAstrometry false.
config.processCcd.calibrate.requireAstrometry=True

# Write reference matches (ignored if doWrite false)?
config.processCcd.calibrate.doWriteMatches=True

# Default reference catalog filter to use if filter not specified in exposure; if blank then filter must be specified in exposure
config.processCcd.calibrate.photoRefObjLoader.defaultFilter=''

# Mapping of camera filter name: reference catalog filter name; each reference filter must exist
config.processCcd.calibrate.photoRefObjLoader.filterMap={'y': 'z', 'i2': 'i', 'N387': 'g', 'N515': 'g', 'N816': 'i', 'N1010': 'z', 'N921': 'z', 'r2': 'r'}

# Padding to add to 4 all edges of the bounding box (pixels)
# 	Valid Range = [0,inf)
config.processCcd.calibrate.photoRefObjLoader.pixelMargin=50

import lsst.obs.subaru.isr
config.processCcd.isr.retarget(target=lsst.obs.subaru.isr.SubaruIsrTask, ConfigClass=lsst.obs.subaru.isr.SubaruIsrConfig)

# Softening parameter for thumbnail mapping
config.processCcd.isr.thumbnailQ=20.0

# Center of vignetting pattern, in y (focal plane coords)
config.processCcd.isr.vignette.yCenter=100.0

# Radius of vignetting pattern, in focal plane coords
config.processCcd.isr.vignette.radius=17500.0

# Center of vignetting pattern, in x (focal plane coords)
config.processCcd.isr.vignette.xCenter=-100.0

# Maximum number of iterations for the brighter fatter correction
config.processCcd.isr.brighterFatterMaxIter=10

# Mask saturated pixels?
config.processCcd.isr.doSaturation=True

# Correct the amplifiers for their gains
# 
# N.b. this is intended to be used *instead* of doFlat; it's useful if you're measuring system throughput
# 
config.processCcd.isr.doApplyGains=False

# Apply bias frame correction?
config.processCcd.isr.doBias=True

# trim out non-data regions?
config.processCcd.isr.assembleCcd.doTrim=True

# set gain?
config.processCcd.isr.assembleCcd.setGain=True

# renormalize to a gain of 1? (ignored if setGain false). Setting to True gives 1 ADU per electron. Setting to True is not recommended for mosaic cameras because it breaks normalization across the focal plane. However, if the CCDs are sufficiently flat then the resulting error may be acceptable.
config.processCcd.isr.assembleCcd.doRenorm=False

# FITS headers to remove (in addition to DATASEC, BIASSEC, TRIMSEC and perhaps GAIN)
config.processCcd.isr.assembleCcd.keysToRemove=[]

# Do fringe subtraction after flat-fielding?
config.processCcd.isr.fringeAfterFlat=True

import lsst.obs.subaru.crosstalk
config.processCcd.isr.crosstalk.retarget(target=lsst.obs.subaru.crosstalk.CrosstalkTask, ConfigClass=lsst.obs.subaru.crosstalk.CrosstalkConfig)

# Set crosstalk mask plane for pixels over this value
config.processCcd.isr.crosstalk.minPixelToMask=45000.0

# Crosstalk coefficients
config.processCcd.isr.crosstalk.coeffs.values=[0.0, -0.000125, -0.000149, -0.000156, -0.000124, 0.0, -0.000132, -0.000157, -0.000171, -0.000134, 0.0, -0.000153, -0.000157, -0.000151, -0.000137, 0.0]

# Shape of coeffs array
config.processCcd.isr.crosstalk.coeffs.shape=[4, 4]

# Name for crosstalk mask plane
config.processCcd.isr.crosstalk.crosstalkMaskPlane='CROSSTALK'

# The method for fitting the overscan bias level.
# Allowed values:
# 	AKIMA_SPLINE	Fit Akima spline to the longest axis of the overscan region
# 	MEDIAN	Correct using the median of the overscan region
# 	LEG	Fit Legendre polynomial to the longest axis of the overscan region
# 	None	Field is optional
# 	MEAN	Correct using the mean of the overscan region
# 	CHEB	Fit Chebyshev polynomial to the longest axis of the overscan region
# 	POLY	Fit ordinary polynomial to the longest axis of the overscan region
# 	NATURAL_SPLINE	Fit natural spline to the longest axis of the overscan region
# 	CUBIC_SPLINE	Fit cubic spline to the longest axis of the overscan region
# 
config.processCcd.isr.overscanFitType='AKIMA_SPLINE'

# How to estimate the average value for BAD regions.
# Allowed values:
# 	MEANCLIP	Correct using the (clipped) mean of good data
# 	MEDIAN	Correct using the median of the good data
# 	None	Field is optional
# 
config.processCcd.isr.badStatistic='MEANCLIP'

# Apply fringe correction?
config.processCcd.isr.doFringe=True

# Mesh size in X (pix) to calculate count statistics
config.processCcd.isr.qa.flatness.meshX=256

# Do we clip outliers in calculate count statistics?
config.processCcd.isr.qa.flatness.doClip=True

# How many sigma is used to clip outliers in calculate count statistics?
config.processCcd.isr.qa.flatness.clipSigma=3.0

# How many times do we iterate clipping outliers in calculate count statistics?
config.processCcd.isr.qa.flatness.nIter=3

# Mesh size in Y (pix) to calculate count statistics
config.processCcd.isr.qa.flatness.meshY=256

# Write OverScan-Subtracted thumbnail?
config.processCcd.isr.qa.doThumbnailOss=True

# Write OverScan-Subtracted image?
config.processCcd.isr.qa.doWriteOss=False

# Write flattened image?
config.processCcd.isr.qa.doWriteFlattened=False

# Write flattened thumbnail?
config.processCcd.isr.qa.doThumbnailFlattened=True

# Should the gain be applied when applying the brighter fatter correction?
config.processCcd.isr.brighterFatterApplyGain=True

# The approximate flux of a zero-magnitude object in a one-second exposure, per filter
config.processCcd.isr.fluxMag0T1={'y': 91201083935.59116, 'N515': 20892961308.54041, 'r': 398107170553.49854, 'z': 120226443461.74132, 'g': 398107170553.49854, 'N921': 19054607179.632523, 'N816': 15848931924.611174, 'i': 275422870333.81744}

# Name of mask plane to use for suspect pixels
config.processCcd.isr.suspectMaskName='SUSPECT'

# The gain to use if no Detector is present in the Exposure (ignored if NaN)
config.processCcd.isr.gain=float('nan')

# The read noise to use if no Detector is present in the Exposure
config.processCcd.isr.readNoise=0.0

# Do overscan subtraction?
config.processCcd.isr.doOverscan=True

# Normalize all the amplifiers in each CCD to have the same gain
# 
# This does not measure the gains, it simply forces the median of each amplifier to be equal
# after applying the nominal gain
# 
config.processCcd.isr.normalizeGains=False

# Number of points to define the Vignette polygon
config.processCcd.isr.numPolygonPoints=100

# Border around saturated pixels for thumbnail
config.processCcd.isr.thumbnailSatBorder=2

# If flatScalingType is 'USER' then scale flat by this amount; ignored otherwise
config.processCcd.isr.flatUserScale=1.0

# Assemble amp-level calibration exposures into ccd-level exposure?
config.processCcd.isr.doAssembleIsrExposures=False

# Tweak flats to match observed amplifier ratios?
config.processCcd.isr.doTweakFlat=False

# Assemble amp-level exposures into a ccd-level exposure?
config.processCcd.isr.doAssembleCcd=True

# Default value for fluxMag0T1 (for an unrecognised filter)
config.processCcd.isr.defaultFluxMag0T1=158489319246.11172

# Apply the brighter fatter correction
config.processCcd.isr.doBrighterFatter=True

# Only fringe-subtract these filters
config.processCcd.isr.fringe.filters=['y', 'N921']

# Sigma clip threshold
config.processCcd.isr.fringe.clip=3.0

# Half-size of large (background) measurements (pixels)
config.processCcd.isr.fringe.large=30

# Half-size of small (fringe) measurements (pixels)
config.processCcd.isr.fringe.small=3

# Ignore pixels with these masks
config.processCcd.isr.fringe.stats.badMaskPlanes=['SAT', 'NO_DATA']

# Statistic to use
config.processCcd.isr.fringe.stats.stat=32

# Sigma clip threshold
config.processCcd.isr.fringe.stats.clip=3.0

# Offset to the random number generator seed (full seed includes exposure ID)
config.processCcd.isr.fringe.stats.rngSeedOffset=0

# Number of fitting iterations
config.processCcd.isr.fringe.stats.iterations=3

# Remove fringe pedestal?
config.processCcd.isr.fringe.pedestal=False

# Number of fitting iterations
config.processCcd.isr.fringe.iterations=20

# Number of fringe measurements
config.processCcd.isr.fringe.num=30000

# Correct for crosstalk
config.processCcd.isr.doCrosstalk=True

# Name of mask plane to use in saturation detection and interpolation
config.processCcd.isr.saturatedMaskName='SAT'

# Apply dark frame correction?
config.processCcd.isr.doDark=True

# Persist postISRCCD?
config.processCcd.isr.doWrite=False

# update exposure metadata in the assembled ccd to reflect the effective gain of the assembled chip
config.processCcd.isr.setGainAssembledCcd=True

# Order of polynomial or to fit if overscan fit type is a polynomial, or number of spline knots if overscan fit type is a spline.
config.processCcd.isr.overscanOrder=30

# Number of pixels by which to grow the saturation footprints
config.processCcd.isr.growSaturationFootprintSize=1

# Correct for nonlinearity of the detector's response?
config.processCcd.isr.doLinearize=True

# Apply flat field correction?
config.processCcd.isr.doFlat=True

# Fallback default filter name for calibrations
config.processCcd.isr.fallbackFilterName=None

# Range for thumbnail mapping
config.processCcd.isr.thumbnailRange=5.0

# Threshold used to stop iterating the brighter fatter correction.  It is the  absolute value of the difference between the current corrected image and the one from the previous iteration summed over all the pixels.
config.processCcd.isr.brighterFatterThreshold=1000.0

# Persist Polygon used to define vignetted region?
config.processCcd.isr.doWriteVignettePolygon=True

# FWHM of PSF used when interpolating over bad columns (arcsec)
config.processCcd.isr.fwhmForBadColumnInterpolation=1.0

# Dataset type for input data; users will typically leave this alone, but camera-specific ISR tasks will override it
config.processCcd.isr.datasetType='raw'

# Trim guider shadow
config.processCcd.isr.doGuider=False

# FWHM of PSF (arcsec)
config.processCcd.isr.fwhm=1.0

# The saturation level to use if no Detector is present in the Exposure (ignored if NaN)
config.processCcd.isr.saturation=float('nan')

# Number of stdev below the background to set thumbnail minimum
config.processCcd.isr.thumbnailStdev=3.0

# Mask suspect pixels?
config.processCcd.isr.doSuspect=True

# Should we set the level of all BAD patches of the chip to the chip's average value?
config.processCcd.isr.doSetBadRegions=True

# Binning factor for thumbnail
config.processCcd.isr.thumbnailBinning=4

# Widen bleed trails based on their width?
config.processCcd.isr.doWidenSaturationTrails=True

# Maximum deviation from the median for overscan
config.processCcd.isr.overscanMaxDev=1000.0

# Kernel file used for the brighter fatter correction
config.processCcd.isr.brighterFatterKernelFile=''

# Calculate variance?
config.processCcd.isr.doVariance=True

# fields to remove from the metadata of the assembled ccd.
config.processCcd.isr.keysToRemoveFromAssembledCcd=[]

# Mask defect pixels?
config.processCcd.isr.doDefect=True

# Rejection threshold (sigma) for collapsing overscan before fit
config.processCcd.isr.overscanRej=3.0

# The method for scaling the flat on the fly.
# Allowed values:
# 	MEAN	Scale by the inverse of the mean
# 	USER	Scale by flatUserScale
# 	MEDIAN	Scale by the inverse of the median
# 	None	Field is optional
# 
config.processCcd.isr.flatScalingType='USER'

# Remove any PC cards in the header
config.processCcd.isr.removePcCards=True

# List of CCDs to ignore when processing
config.ignoreCcdList=[]

